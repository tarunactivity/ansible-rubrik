# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.serialization import Model


class GlobalThorConfig(Model):
    """GlobalThorConfig.

    :param archival_lock_manager_cache_timeout_in_milis: The archival lock
     manager caches the contents of the cluster lock file and the cluster
     encryption file. This specifies the expiration time on that cache.
    :type archival_lock_manager_cache_timeout_in_milis: int
    :param azure_upload_stream_size_in_mb: For Azure we upload files in
     chunks. This specifies the size of that chunk. For prod it is set to 5
     Gigs
    :type azure_upload_stream_size_in_mb: int
    :param use_nfs_upload_in_blocks: This is a feature toggle for NFS block
     uploading. When false, NFS will upload files in a single part. When true,
     NFS will use the same codepath as Azure for block uploading.
    :type use_nfs_upload_in_blocks: bool
    :param use_nfs_upload_in_blocks_with_file_channel: This is a feature
     toggle for an improvement over NFS block uploading. NFS upload in single
     part uses FileChannel to copy the file, whereas the Azure codepath does
     not. This feature uses FileChannel together with block uploading.
    :type use_nfs_upload_in_blocks_with_file_channel: bool
    :param default_chunk_size_for_encrypted_file_channel_transfer_in_mi_b:
     While sending files over NFS, we use FileChannels to send data instead of
     using java InputStreams as FileChannels are much faster. In order to use
     FileChannel, we either need a file or a byte array. When we have encrypted
     streams, we do not want to instantiate a file from the encrypted stream.
     That leaves us with the option of instantiating byte arrays out of the
     encrypted stream. As the stream can be huge, it is not possible to simply
     convert the entire stream to a byte array, so we instantiate the byte
     arrays one chunk at a time. This config dictates the size of such a chunk.
    :type default_chunk_size_for_encrypted_file_channel_transfer_in_mi_b: int
    :param nfs_upload_stream_size_in_mb: For NFS we upload files in chunks.
     This specifies the size of that chunk. For prod it is set to 5 Gigs
    :type nfs_upload_stream_size_in_mb: int
    :param ignore_encryption_password_and_create_unencrypted_nfs_location: We
     no longer allow creation of NFS archival locations without encryption. But
     to test backward compatibility, we still need a way to create such
     unencrypted locations in tests. This flag, when enabled, makes the NFS
     location creation code simply ignore the `encryptionPassword` REST
     parameter.
    :type ignore_encryption_password_and_create_unencrypted_nfs_location: bool
    :param use_qstar_upload_in_blocks: This is a feature toggle for Qstar
     block uploading. When false, Qstar will upload files in a single part.
     When true, it will use the same codepath as Azure for block uploading.
    :type use_qstar_upload_in_blocks: bool
    :param qstar_max_thread_count_for_upload: Max number of threads used to
     upload a file to Qstar
    :type qstar_max_thread_count_for_upload: int
    :param qstar_upload_stream_size_in_mb: For Qstar archival, we upload files
     in chunks. This specifies the size of that chunk. For prod it is set to 5
     Gigs
    :type qstar_upload_stream_size_in_mb: int
    :param qstar_support_incremental_snapshots: For Qstar archival, we upload
     only full snapshots. When true, incremental snapshots will be uploaded.
    :type qstar_support_incremental_snapshots: bool
    :param use_qstar_web_services_for_status_checks: Use QStar webservices
     APIs to check space availability, file accessibility, and other
     conditions.
    :type use_qstar_web_services_for_status_checks: bool
    :param fail_file_accessible_check: Fail the QStar file accessible check
     when set. This is for testing purposes.
    :type fail_file_accessible_check: bool
    :param fail_space_available_check: Fail the QStar space available check
     when set. This is for testing purposes.
    :type fail_space_available_check: bool
    :param chunk_size_for_encryption_authentication_in_kb: For Google Storage,
     we encrypt data client-side and hash chunks to ensure integrity. This
     specifies the size of each chunk to be hashed.
    :type chunk_size_for_encryption_authentication_in_kb: int
    :param threshold_for_uploading_full_in_minutes: Threshold in minutes after
     which we should try to upload a full to archival location (30 * 24 * 60)
    :type threshold_for_uploading_full_in_minutes: int
    :param archival_threshold_multiplier_for_full_upload: We should only
     upload a full if time elapsed since last full is greater than
     archivalThresholdMultiplierForFullUpload * archival threshold. This will
     ensure that we are not uploading fulls that often
    :type archival_threshold_multiplier_for_full_upload: int
    :param min_time_for_uploading_full_in_minutes: Minimum time for which we
     should wait before uploading full even if other conditions are met (15 *
     24 * 60)
    :type min_time_for_uploading_full_in_minutes: int
    :param percent_change_rate_for_uploading_full: Percent change rate of a
     virtual disk which would make it neccessary to upload a full
    :type percent_change_rate_for_uploading_full: int
    :param max_full_upload_refs_count: Max count of jobs that can upload full
     snapshots
    :type max_full_upload_refs_count: int
    :param min_full_upload_refs_count: Min count of jobs that can upload full
     snapshots
    :type min_full_upload_refs_count: int
    :param max_archive_jobs_that_can_run_on_cluster: Max number of archive
     jobs that will run on the cluster irrespective of whether a full or
     increment is being archived
    :type max_archive_jobs_that_can_run_on_cluster: int
    :param pct_of_full_upload_jobs_per_node: Percentage of upload jobs per
     node that can upload full. If we have n jobs running per node then we can
     have max pctOfFullUploadJobsPerNode * n * numNodes jobs that can upload
     full
    :type pct_of_full_upload_jobs_per_node: float
    :param force_full_upload_to_archival_store: Force a full upload to
     archival store
    :type force_full_upload_to_archival_store: bool
    :param chunk_download_retry_count: Retry count for chunk download from
     object store in case of a network flap
    :type chunk_download_retry_count: int
    :param chunk_download_backoff_initial_range_in_ms: Initial back off time
     for chunk download in case of a failure
    :type chunk_download_backoff_initial_range_in_ms: int
    :param ec2_ebs_volume_type: Type of the volume to use for instantiating
     EBS volumes
    :type ec2_ebs_volume_type: str
    :param ec2_ebs_device_id: Device Id to use for the EBS volume
    :type ec2_ebs_device_id: str
    :param ec2_ebs_mount_point: Mount point to use to mount the EBS volume
    :type ec2_ebs_mount_point: str
    :param drop_count_in_archival_bandwidth_query: Num of elements to drop
     from the archival bandwidth query This is needed because the first few
     elements have very high value and ui currently doesn't provide zooming
     capability in the graph as a result of which rest of the graph looks
     really skewed. Therefore dropping first few elements
    :type drop_count_in_archival_bandwidth_query: int
    :param download_snapshot_from_cloud_job_in_memory_sem_shares: Maximum
     number of concurrent download snapshot from cloud jobs per node
    :type download_snapshot_from_cloud_job_in_memory_sem_shares: int
    :param max_s3_file_size_in_mb: Max File size that S3 supports
    :type max_s3_file_size_in_mb: int
    :param max_disk_size_for_cloud_upload_in_gb: Max Disk Space that should be
     used by multi part upload s3 api
    :type max_disk_size_for_cloud_upload_in_gb: int
    :param part_size_for_cloud_upload_in_mb: Default part size used for cloud
     upload
    :type part_size_for_cloud_upload_in_mb: int
    :param max_part_size_for_cloud_upload_in_mb: Maximum part Size used by
     multi part upload s3 api
    :type max_part_size_for_cloud_upload_in_mb: int
    :param max_num_parts_for_cloud_upload: Maximum number of parts for a
     single upload to S3
    :type max_num_parts_for_cloud_upload: int
    :param aws_max_connections_to_s3: The maximum number of allowed open HTTP
     connections to S3
    :type aws_max_connections_to_s3: int
    :param aws_socket_timeout_in_millis: Timeout for reading from a connected
     socket. default 50 seconds
    :type aws_socket_timeout_in_millis: int
    :param aws_connection_timeout_in_millis: Timeout for creating new
     connections. Deafult 10 seconds
    :type aws_connection_timeout_in_millis: int
    :param aws_connection_max_idle_millis: The maximum idle time (in
     milliseconds) for a connection in the connection pool. Default 60 seconds
    :type aws_connection_max_idle_millis: int
    :param aws_max_retries_for_retryable_errors: Maximum number of retry
     attempts for failed retryable requests.
    :type aws_max_retries_for_retryable_errors: int
    :param part_upload_retry_count: Retry count for uploading chunks to S3.
     This is the number of times we retry irrespective of what the failure is
    :type part_upload_retry_count: int
    :param part_upload_initial_sleep_in_ms: Initial sleep time in ms when
     doing back off during part uploads
    :type part_upload_initial_sleep_in_ms: int
    :param ttl_for_ajenkins_test_bucket_in_hours: For buckets used in jenkins
     test we will delete all files in that particular bucket if any file in
     that bucket exceeds the TTL value
    :type ttl_for_ajenkins_test_bucket_in_hours: int
    :param max_download_snapshot_retries: Number of retries of the download
     job which is an one off job
    :type max_download_snapshot_retries: int
    :param archival_key_download_batch_size: Size of the batch while
     downloading archival keys
    :type archival_key_download_batch_size: int
    :param ec2_image_id: Ec2 ami id for the specific os which can be used to
     launch an ec2 instance
    :type ec2_image_id: str
    :param ec2_instance_type: Ec2 ami id for the specific os which can be used
     to launch an ec2 instance
    :type ec2_instance_type: str
    :param trust_object_store_tls_certificate_on_first_use: Sets whether or
     not we should trust self signed certificates from private object stores
    :type trust_object_store_tls_certificate_on_first_use: bool
    :param tls_protocol_for_private_object_stores: TLS protocol to be used
     when connecting to private object stores
    :type tls_protocol_for_private_object_stores: str
    :param initial_heap_size_for_rubrik_bolt_service: Initial heap size for
     Rubrik Bolt Service, ie -Xms
    :type initial_heap_size_for_rubrik_bolt_service: str
    :param max_heap_size_for_rubrik_bolt_service: max heap size for Rubrik
     Bolt Service, ie -Xmx
    :type max_heap_size_for_rubrik_bolt_service: str
    :param allow_list_all_keys_for_gc: Sets whether or not we list all keys to
     delete with a prefix on archival GC, since it could be costly
    :type allow_list_all_keys_for_gc: bool
    :param multi_part_upload_directory: Temporary directory where chunks are
     written to before being uploaded by AWS SDK
    :type multi_part_upload_directory: str
    :param sample_fingerprints_to_validate: Number of fingerprints to validate
     after archival of a subobject
    :type sample_fingerprints_to_validate: int
    :param cache_block_size_in_mb: Block size used by Archival Service helper
     to download from archival source
    :type cache_block_size_in_mb: int
    :param archival_service_helper_thrift_timeout_in_seconds: Archival Service
     Helper Thrift Timeout In seconds
    :type archival_service_helper_thrift_timeout_in_seconds: int
    :param non_cacheable_key_ttl_in_seconds: TTL in seconds for non Cacheable
     keys that are used for fingerprint validation after snapshot upload
    :type non_cacheable_key_ttl_in_seconds: int
    :param retry_for_uploading_sub_object_in_archive_job: Number of retries to
     archive a subobject
    :type retry_for_uploading_sub_object_in_archive_job: int
    :param retry_for_validating_patch_files_after_archive: Number of retries
     to validate an archived patch file
    :type retry_for_validating_patch_files_after_archive: int
    :param probability_in_percent_to_clear_non_cacheable_keys: Probabilty to
     clear keys that have excceded TTL in non cachable keys map
    :type probability_in_percent_to_clear_non_cacheable_keys: int
    :param sub_objects_to_upload_in_parallel: Count of subobjects that can be
     uploaded in parallel
    :type sub_objects_to_upload_in_parallel: int
    :param sub_objects_to_download_in_parallel: Count of subobjects that can
     be downloaded in parallel
    :type sub_objects_to_download_in_parallel: int
    :param validate_fingerprints_after_download: Flag whether to validate
     fingerprints after downlaod
    :type validate_fingerprints_after_download: bool
    :param exit_archival_recovery_job_cleanly: Flag to indicate clean exit of
     the ArchivalRecovery job. Recovery job runs in a rollforward task and
     tries to recover all snappables, in case of even one faliure it will keep
     on retrying and holding on to all the throttles This flag is just a manual
     indication for the recovery job to exit
    :type exit_archival_recovery_job_cleanly: bool
    :param allow_launching_bolt: Flag to indicate if we can instantiate rubrik
     bolt. Sometimes customers might not want to do that because it incurs cost
     to launch a new instance on cloud
    :type allow_launching_bolt: bool
    :param rubrik_bolt_aws_instance_type: Instance type for launching rubrik
     bolt in aws
    :type rubrik_bolt_aws_instance_type: str
    :param bolt_cloud_image_prefix: Prefix for naming rubrik image on cloud
    :type bolt_cloud_image_prefix: str
    :param recovery_skip_path_verification: Flag for skipping the path
     verification. Path verification could be time consuming as it will operate
     on all the snapshots of the snappable and query the cloud to see if the
     path actually exists
    :type recovery_skip_path_verification: bool
    :param throttle_wait_time_in_seconds: Wait time in seconds to acquire
     throttle
    :type throttle_wait_time_in_seconds: int
    :param throttle_sleep_time_in_seconds: Sleep time in seconds for acquiring
     throttle
    :type throttle_sleep_time_in_seconds: int
    :param upgrade_required_for_archival_store: Flag whether to upgrade an
     Archival Store. This is required as part of moving from 2.x to 3.x. The
     upgrade job will also look at the version of archival store, so it is safe
     to set this as true as there are other conditons that need to be met
     before actual upgrade takes place. The upgrade job on successful exit will
     set this flag to false
    :type upgrade_required_for_archival_store: bool
    :param upgrade_archival_store_frequency_in_minutes: Time interval between
     each upgrade job run
    :type upgrade_archival_store_frequency_in_minutes: int
    :param cloud_instantiation_job_frequency_in_minutes: Time interval between
     each instantiation job run
    :type cloud_instantiation_job_frequency_in_minutes: int
    :param use_archival_lock_manager_cache: Feature toggle specifying whether
     to use a cache for the archival lock manager.
    :type use_archival_lock_manager_cache: bool
    :param upload_percent_disk_space_needed: Percentage of logical disk space
     required to construct patch files for upload. Scratch dir does not have
     replication so we will be using only x /(3/2) disk space. We can further
     divide it by a factor of 2.75 provided by zstd compression.So the factor
     of disk usage comes out to be (2/3)/2.75 = 0.24
    :type upload_percent_disk_space_needed: float
    :param disk_space_reserved_on_archive_for_metadata_in_mb: We need some
     disk space reserved in the archive for doing metadata operations when
     running expiration or gc on a blobstore group.
    :type disk_space_reserved_on_archive_for_metadata_in_mb: int
    :param is_private_object_store_out_of_space: This flag can be set to True
     if we discover that private object store is out of space to do metadata
     operations.
    :type is_private_object_store_out_of_space: bool
    :param acceptable_archival_threshold_violation_in_hours: Grace period we
     give a snapshot to be archived, in hours
    :type acceptable_archival_threshold_violation_in_hours: int
    :param aws_s3_apn_user_agent_string: Aws User agent string used to track
     data uploaded by Rubrik on AWS' side
    :type aws_s3_apn_user_agent_string: str
    :param archival_location_connectivity_check_frequency_in_minutes: Time
     interval between each connectivity check run
    :type archival_location_connectivity_check_frequency_in_minutes: int
    :param sleep_time_for_connectivity_check_in_minutes: Time interval between
     each connectivity check run
    :type sleep_time_for_connectivity_check_in_minutes: int
    :param import_image_wait_time_in_minutes: The time to wait for an import
     image job
    :type import_image_wait_time_in_minutes: int
    :param import_image_sleep_time_in_seconds: Time between each time we check
     the import image job progress
    :type import_image_sleep_time_in_seconds: int
    :param cloud_transient_image_gc_time_in_seconds: Time to garbage clean a
     transient cloud image after it is created
    :type cloud_transient_image_gc_time_in_seconds: int
    :param generic_compute_wait_time_in_seconds: Time to wait for compute
     tasks without specific configs
    :type generic_compute_wait_time_in_seconds: int
    :param generic_compute_sleep_time_in_seconds: Time to sleep for compute
     tasks without specific configs
    :type generic_compute_sleep_time_in_seconds: int
    :param max_instantiate_job_instances_per_node: The maximum number of cloud
     instantiation job instances per node
    :type max_instantiate_job_instances_per_node: int
    :param upload_job_no_work_delay_in_millis: Number of milliseconds to delay
     the job if there is no work to do
    :type upload_job_no_work_delay_in_millis: int
    :param cloud_instantiate_delay_in_millis_if_no_archived_snapshot: Number
     of milliseconds to delay cloud instantiation job if no snapshot exists at
     archival location
    :type cloud_instantiate_delay_in_millis_if_no_archived_snapshot: int
    :param cloud_instantiate_default_image_conversion_frequency_in_seconds:
     Interval at which the instantiation job runs to convert the latest
     snapshot to a cloud image.
    :type cloud_instantiate_default_image_conversion_frequency_in_seconds: int
    :param cloud_instantiate_default_image_retention_in_seconds: Specifies the
     number of seconds to retain a cloud image that is generated for a
     snappable.
    :type cloud_instantiate_default_image_retention_in_seconds: int
    :param instantiate_snapshot_job_retries: Number of retries for
     instantiating snapshots on cloud
    :type instantiate_snapshot_job_retries: int
    :param retry_for_uploading_in_instantiate_job: Number of retries for all
     uploads required in the cloud instantiate job
    :type retry_for_uploading_in_instantiate_job: int
    :param retry_for_converting_to_stream_optimized_vmdk: Number of retries
     for converting monolithic flat VMDK to stream-optimized VMDK in
     instantiate job
    :type retry_for_converting_to_stream_optimized_vmdk: int
    :param sub_objects_to_convert_for_instantiation_in_parallel: Number of sub
     objects that can be operated on for instantiation conversion / upload
     tasks in parallel
    :type sub_objects_to_convert_for_instantiation_in_parallel: int
    :param ssh_socket_port: Socket port to allow inbound ssh traffic
    :type ssh_socket_port: int
    :param skip_rubrik_bolt_shut_down_in_cloud_instantation: For debugging
     purposes we might want access to live instance for debugging, so
     preventing auto shutdown during failures
    :type skip_rubrik_bolt_shut_down_in_cloud_instantation: bool
    :param bolt_security_group_id: Security Group to be used for bolt instance
     on customer public cloud. Note that this security group must allow the
     brik to connect to bolt instance using Private IP allowing traffic from
     ports 2002 and 7780.
    :type bolt_security_group_id: str
    :param bolt_subnet_id_for_instantiation: Subnet to be used for bolt
     instance on customer public cloud.
    :type bolt_subnet_id_for_instantiation: str
    :param use_public_ip_for_bolt: Use public IP for connecting to bolt. Note
     that we use private IP by default which expects the customer to have VPN
     set up. Ensure that Security Group used for bolt instance allows traffic
     on public IP.
    :type use_public_ip_for_bolt: bool
    :param cloud_storage_service_socket_timeout_in_ms: Timeout in Ms for
     client timeout for Cloud storage service
    :type cloud_storage_service_socket_timeout_in_ms: int
    :param default_chunk_size_to_encrypt_for_archival_in_ki_b: While uploading
     to an encrypted archival location, we break down the data into chunks and
     encrypt them individually. This is the default size of these chunks in KiB
    :type default_chunk_size_to_encrypt_for_archival_in_ki_b: int
    :param bolt_instances_certificates_directory: Directory under which all
     bolts instances certificates will be stored
    :type bolt_instances_certificates_directory: str
    :param retry_count_for_rubrik_bolt_instance: Number of times to retry when
     establishing contact with bolt instance
    :type retry_count_for_rubrik_bolt_instance: int
    :param max_cloud_instantiate_jobs_per_bolt: Maximum number of cloud
     instantiation jobs running on a bolt
    :type max_cloud_instantiate_jobs_per_bolt: int
    :param delete_cloud_instance_job_retries: Number of retries for deleting
     cloud instances
    :type delete_cloud_instance_job_retries: int
    :param delete_cloud_image_job_retries: Number of retries for deleting
     cloud images
    :type delete_cloud_image_job_retries: int
    :param use_bolt_for_instantiation: This is a toggle for allowing bolt for
     instantiation
    :type use_bolt_for_instantiation: bool
    :param bolt_machine_image_id_for_instantiation: This is a hardcoded image
     id used in case we want to use a hotfix AMI for instantiation. If it's
     dummy, we use one based on codeVersion.
    :type bolt_machine_image_id_for_instantiation: str
    :param bolt_cloud_init_script_file_path: This is a cloud init script. May
     change in case we want to use a hotfix for instantiation.
    :type bolt_cloud_init_script_file_path: str
    :param time_to_wait_for_thrift_job_instance_in_hours: Time to wait for a
     thrift-initiated job instance to complete
    :type time_to_wait_for_thrift_job_instance_in_hours: int
    :param sleep_time_for_checking_thrift_job_instance_in_millis: Time between
     consecutive checks of thrift-initiated job instance
    :type sleep_time_for_checking_thrift_job_instance_in_millis: int
    :param qstar_download_fingerprint_sampling_ratio: Sampling ratio for
     fingerprint verification when downloading snapshot from Qstar
    :type qstar_download_fingerprint_sampling_ratio: float
    :param generic_retry_count: Generic retry count to be used in thor code
    :type generic_retry_count: int
    :param sleep_time_for_checking_thrift_job_instance_in_ms: Time between
     consecutive checks of thrift-initiated job instance
    :type sleep_time_for_checking_thrift_job_instance_in_ms: int
    :param retry_count_for_fetching_logs_from_bolt_instance: Number of times
     to retry when fetching logs from the bolt instance
    :type retry_count_for_fetching_logs_from_bolt_instance: int
    :param bolt_log_dir: Top level dir where bolt logs are copied locally.
     Will be created if it doesn't exist.
    :type bolt_log_dir: str
    :param bolt_log_min_free_space_fraction: Bolt logs won't be copied locally
     if the free space on the local partition will fall below this fraction.
    :type bolt_log_min_free_space_fraction: float
    :param bolt_log_max_size_in_mb: Bolt logs won't be copied locally if the
     log bundle size is more than this value.
    :type bolt_log_max_size_in_mb: int
    :param bolt_log_dir_max_size_fraction: Bolt logs won't be copied locally
     if boltLogDir size will become more than this fraction of total space on
     local partition.
    :type bolt_log_dir_max_size_fraction: float
    :param thrift_socket_connection_timeout_in_seconds: Thrift connection
     timeout when accessing the Archive (S3) random access services.
    :type thrift_socket_connection_timeout_in_seconds: int
    :param thrift_socket_send_timeout_in_seconds: Thrift socket send timeout
     when accessing the Archive (S3) random access services.
    :type thrift_socket_send_timeout_in_seconds: int
    :param thrift_socket_receive_timeout_in_seconds: Thrift socket receive
     timeout when accessing the Archive (S3) random access services.
    :type thrift_socket_receive_timeout_in_seconds: int
    :param hds_enable_multi_part_upload: Enable multipart upload for HDS
     archival locations.
    :type hds_enable_multi_part_upload: bool
    :param nfs_supported_options: Nfs supported options. List of options is
     separated by a semicolon and the list of valid option values is comma
     separated.
    :type nfs_supported_options: str
    :param nfs_default_options: Nfs default options. CSV list of options.
    :type nfs_default_options: str
    """

    _attribute_map = {
        'archival_lock_manager_cache_timeout_in_milis': {'key': 'archivalLockManagerCacheTimeoutInMilis', 'type': 'int'},
        'azure_upload_stream_size_in_mb': {'key': 'azureUploadStreamSizeInMB', 'type': 'int'},
        'use_nfs_upload_in_blocks': {'key': 'useNfsUploadInBlocks', 'type': 'bool'},
        'use_nfs_upload_in_blocks_with_file_channel': {'key': 'useNfsUploadInBlocksWithFileChannel', 'type': 'bool'},
        'default_chunk_size_for_encrypted_file_channel_transfer_in_mi_b': {'key': 'defaultChunkSizeForEncryptedFileChannelTransferInMiB', 'type': 'int'},
        'nfs_upload_stream_size_in_mb': {'key': 'nfsUploadStreamSizeInMB', 'type': 'int'},
        'ignore_encryption_password_and_create_unencrypted_nfs_location': {'key': 'ignoreEncryptionPasswordAndCreateUnencryptedNfsLocation', 'type': 'bool'},
        'use_qstar_upload_in_blocks': {'key': 'useQstarUploadInBlocks', 'type': 'bool'},
        'qstar_max_thread_count_for_upload': {'key': 'qstarMaxThreadCountForUpload', 'type': 'int'},
        'qstar_upload_stream_size_in_mb': {'key': 'qstarUploadStreamSizeInMB', 'type': 'int'},
        'qstar_support_incremental_snapshots': {'key': 'qstarSupportIncrementalSnapshots', 'type': 'bool'},
        'use_qstar_web_services_for_status_checks': {'key': 'useQstarWebServicesForStatusChecks', 'type': 'bool'},
        'fail_file_accessible_check': {'key': 'failFileAccessibleCheck', 'type': 'bool'},
        'fail_space_available_check': {'key': 'failSpaceAvailableCheck', 'type': 'bool'},
        'chunk_size_for_encryption_authentication_in_kb': {'key': 'chunkSizeForEncryptionAuthenticationInKB', 'type': 'int'},
        'threshold_for_uploading_full_in_minutes': {'key': 'thresholdForUploadingFullInMinutes', 'type': 'int'},
        'archival_threshold_multiplier_for_full_upload': {'key': 'archivalThresholdMultiplierForFullUpload', 'type': 'int'},
        'min_time_for_uploading_full_in_minutes': {'key': 'minTimeForUploadingFullInMinutes', 'type': 'int'},
        'percent_change_rate_for_uploading_full': {'key': 'percentChangeRateForUploadingFull', 'type': 'int'},
        'max_full_upload_refs_count': {'key': 'maxFullUploadRefsCount', 'type': 'int'},
        'min_full_upload_refs_count': {'key': 'minFullUploadRefsCount', 'type': 'int'},
        'max_archive_jobs_that_can_run_on_cluster': {'key': 'maxArchiveJobsThatCanRunOnCluster', 'type': 'int'},
        'pct_of_full_upload_jobs_per_node': {'key': 'pctOfFullUploadJobsPerNode', 'type': 'float'},
        'force_full_upload_to_archival_store': {'key': 'forceFullUploadToArchivalStore', 'type': 'bool'},
        'chunk_download_retry_count': {'key': 'chunkDownloadRetryCount', 'type': 'int'},
        'chunk_download_backoff_initial_range_in_ms': {'key': 'chunkDownloadBackoffInitialRangeInMs', 'type': 'int'},
        'ec2_ebs_volume_type': {'key': 'ec2EbsVolumeType', 'type': 'str'},
        'ec2_ebs_device_id': {'key': 'ec2EbsDeviceId', 'type': 'str'},
        'ec2_ebs_mount_point': {'key': 'ec2EbsMountPoint', 'type': 'str'},
        'drop_count_in_archival_bandwidth_query': {'key': 'dropCountInArchivalBandwidthQuery', 'type': 'int'},
        'download_snapshot_from_cloud_job_in_memory_sem_shares': {'key': 'downloadSnapshotFromCloudJobInMemorySemShares', 'type': 'int'},
        'max_s3_file_size_in_mb': {'key': 'maxS3FileSizeInMB', 'type': 'int'},
        'max_disk_size_for_cloud_upload_in_gb': {'key': 'maxDiskSizeForCloudUploadInGB', 'type': 'int'},
        'part_size_for_cloud_upload_in_mb': {'key': 'partSizeForCloudUploadInMB', 'type': 'int'},
        'max_part_size_for_cloud_upload_in_mb': {'key': 'maxPartSizeForCloudUploadInMB', 'type': 'int'},
        'max_num_parts_for_cloud_upload': {'key': 'maxNumPartsForCloudUpload', 'type': 'int'},
        'aws_max_connections_to_s3': {'key': 'awsMaxConnectionsToS3', 'type': 'int'},
        'aws_socket_timeout_in_millis': {'key': 'awsSocketTimeoutInMillis', 'type': 'int'},
        'aws_connection_timeout_in_millis': {'key': 'awsConnectionTimeoutInMillis', 'type': 'int'},
        'aws_connection_max_idle_millis': {'key': 'awsConnectionMaxIdleMillis', 'type': 'int'},
        'aws_max_retries_for_retryable_errors': {'key': 'awsMaxRetriesForRetryableErrors', 'type': 'int'},
        'part_upload_retry_count': {'key': 'partUploadRetryCount', 'type': 'int'},
        'part_upload_initial_sleep_in_ms': {'key': 'partUploadInitialSleepInMs', 'type': 'int'},
        'ttl_for_ajenkins_test_bucket_in_hours': {'key': 'ttlForAJenkinsTestBucketInHours', 'type': 'int'},
        'max_download_snapshot_retries': {'key': 'maxDownloadSnapshotRetries', 'type': 'int'},
        'archival_key_download_batch_size': {'key': 'archivalKeyDownloadBatchSize', 'type': 'int'},
        'ec2_image_id': {'key': 'ec2ImageId', 'type': 'str'},
        'ec2_instance_type': {'key': 'ec2InstanceType', 'type': 'str'},
        'trust_object_store_tls_certificate_on_first_use': {'key': 'trustObjectStoreTlsCertificateOnFirstUse', 'type': 'bool'},
        'tls_protocol_for_private_object_stores': {'key': 'tlsProtocolForPrivateObjectStores', 'type': 'str'},
        'initial_heap_size_for_rubrik_bolt_service': {'key': 'initialHeapSizeForRubrikBoltService', 'type': 'str'},
        'max_heap_size_for_rubrik_bolt_service': {'key': 'maxHeapSizeForRubrikBoltService', 'type': 'str'},
        'allow_list_all_keys_for_gc': {'key': 'allowListAllKeysForGc', 'type': 'bool'},
        'multi_part_upload_directory': {'key': 'multiPartUploadDirectory', 'type': 'str'},
        'sample_fingerprints_to_validate': {'key': 'sampleFingerprintsToValidate', 'type': 'int'},
        'cache_block_size_in_mb': {'key': 'cacheBlockSizeInMB', 'type': 'int'},
        'archival_service_helper_thrift_timeout_in_seconds': {'key': 'archivalServiceHelperThriftTimeoutInSeconds', 'type': 'int'},
        'non_cacheable_key_ttl_in_seconds': {'key': 'nonCacheableKeyTtlInSeconds', 'type': 'int'},
        'retry_for_uploading_sub_object_in_archive_job': {'key': 'retryForUploadingSubObjectInArchiveJob', 'type': 'int'},
        'retry_for_validating_patch_files_after_archive': {'key': 'retryForValidatingPatchFilesAfterArchive', 'type': 'int'},
        'probability_in_percent_to_clear_non_cacheable_keys': {'key': 'probabilityInPercentToClearNonCacheableKeys', 'type': 'int'},
        'sub_objects_to_upload_in_parallel': {'key': 'subObjectsToUploadInParallel', 'type': 'int'},
        'sub_objects_to_download_in_parallel': {'key': 'subObjectsToDownloadInParallel', 'type': 'int'},
        'validate_fingerprints_after_download': {'key': 'validateFingerprintsAfterDownload', 'type': 'bool'},
        'exit_archival_recovery_job_cleanly': {'key': 'exitArchivalRecoveryJobCleanly', 'type': 'bool'},
        'allow_launching_bolt': {'key': 'allowLaunchingBolt', 'type': 'bool'},
        'rubrik_bolt_aws_instance_type': {'key': 'rubrikBoltAwsInstanceType', 'type': 'str'},
        'bolt_cloud_image_prefix': {'key': 'boltCloudImagePrefix', 'type': 'str'},
        'recovery_skip_path_verification': {'key': 'recoverySkipPathVerification', 'type': 'bool'},
        'throttle_wait_time_in_seconds': {'key': 'throttleWaitTimeInSeconds', 'type': 'int'},
        'throttle_sleep_time_in_seconds': {'key': 'throttleSleepTimeInSeconds', 'type': 'int'},
        'upgrade_required_for_archival_store': {'key': 'upgradeRequiredForArchivalStore', 'type': 'bool'},
        'upgrade_archival_store_frequency_in_minutes': {'key': 'upgradeArchivalStoreFrequencyInMinutes', 'type': 'int'},
        'cloud_instantiation_job_frequency_in_minutes': {'key': 'cloudInstantiationJobFrequencyInMinutes', 'type': 'int'},
        'use_archival_lock_manager_cache': {'key': 'useArchivalLockManagerCache', 'type': 'bool'},
        'upload_percent_disk_space_needed': {'key': 'uploadPercentDiskSpaceNeeded', 'type': 'float'},
        'disk_space_reserved_on_archive_for_metadata_in_mb': {'key': 'diskSpaceReservedOnArchiveForMetadataInMB', 'type': 'int'},
        'is_private_object_store_out_of_space': {'key': 'isPrivateObjectStoreOutOfSpace', 'type': 'bool'},
        'acceptable_archival_threshold_violation_in_hours': {'key': 'acceptableArchivalThresholdViolationInHours', 'type': 'int'},
        'aws_s3_apn_user_agent_string': {'key': 'awsS3ApnUserAgentString', 'type': 'str'},
        'archival_location_connectivity_check_frequency_in_minutes': {'key': 'archivalLocationConnectivityCheckFrequencyInMinutes', 'type': 'int'},
        'sleep_time_for_connectivity_check_in_minutes': {'key': 'sleepTimeForConnectivityCheckInMinutes', 'type': 'int'},
        'import_image_wait_time_in_minutes': {'key': 'importImageWaitTimeInMinutes', 'type': 'int'},
        'import_image_sleep_time_in_seconds': {'key': 'importImageSleepTimeInSeconds', 'type': 'int'},
        'cloud_transient_image_gc_time_in_seconds': {'key': 'cloudTransientImageGcTimeInSeconds', 'type': 'int'},
        'generic_compute_wait_time_in_seconds': {'key': 'genericComputeWaitTimeInSeconds', 'type': 'int'},
        'generic_compute_sleep_time_in_seconds': {'key': 'genericComputeSleepTimeInSeconds', 'type': 'int'},
        'max_instantiate_job_instances_per_node': {'key': 'maxInstantiateJobInstancesPerNode', 'type': 'int'},
        'upload_job_no_work_delay_in_millis': {'key': 'uploadJobNoWorkDelayInMillis', 'type': 'int'},
        'cloud_instantiate_delay_in_millis_if_no_archived_snapshot': {'key': 'cloudInstantiateDelayInMillisIfNoArchivedSnapshot', 'type': 'int'},
        'cloud_instantiate_default_image_conversion_frequency_in_seconds': {'key': 'cloudInstantiateDefaultImageConversionFrequencyInSeconds', 'type': 'int'},
        'cloud_instantiate_default_image_retention_in_seconds': {'key': 'cloudInstantiateDefaultImageRetentionInSeconds', 'type': 'int'},
        'instantiate_snapshot_job_retries': {'key': 'instantiateSnapshotJobRetries', 'type': 'int'},
        'retry_for_uploading_in_instantiate_job': {'key': 'retryForUploadingInInstantiateJob', 'type': 'int'},
        'retry_for_converting_to_stream_optimized_vmdk': {'key': 'retryForConvertingToStreamOptimizedVmdk', 'type': 'int'},
        'sub_objects_to_convert_for_instantiation_in_parallel': {'key': 'subObjectsToConvertForInstantiationInParallel', 'type': 'int'},
        'ssh_socket_port': {'key': 'sshSocketPort', 'type': 'int'},
        'skip_rubrik_bolt_shut_down_in_cloud_instantation': {'key': 'skipRubrikBoltShutDownInCloudInstantation', 'type': 'bool'},
        'bolt_security_group_id': {'key': 'boltSecurityGroupId', 'type': 'str'},
        'bolt_subnet_id_for_instantiation': {'key': 'boltSubnetIdForInstantiation', 'type': 'str'},
        'use_public_ip_for_bolt': {'key': 'usePublicIpForBolt', 'type': 'bool'},
        'cloud_storage_service_socket_timeout_in_ms': {'key': 'cloudStorageServiceSocketTimeoutInMs', 'type': 'int'},
        'default_chunk_size_to_encrypt_for_archival_in_ki_b': {'key': 'defaultChunkSizeToEncryptForArchivalInKiB', 'type': 'int'},
        'bolt_instances_certificates_directory': {'key': 'boltInstancesCertificatesDirectory', 'type': 'str'},
        'retry_count_for_rubrik_bolt_instance': {'key': 'retryCountForRubrikBoltInstance', 'type': 'int'},
        'max_cloud_instantiate_jobs_per_bolt': {'key': 'maxCloudInstantiateJobsPerBolt', 'type': 'int'},
        'delete_cloud_instance_job_retries': {'key': 'deleteCloudInstanceJobRetries', 'type': 'int'},
        'delete_cloud_image_job_retries': {'key': 'deleteCloudImageJobRetries', 'type': 'int'},
        'use_bolt_for_instantiation': {'key': 'useBoltForInstantiation', 'type': 'bool'},
        'bolt_machine_image_id_for_instantiation': {'key': 'boltMachineImageIdForInstantiation', 'type': 'str'},
        'bolt_cloud_init_script_file_path': {'key': 'boltCloudInitScriptFilePath', 'type': 'str'},
        'time_to_wait_for_thrift_job_instance_in_hours': {'key': 'timeToWaitForThriftJobInstanceInHours', 'type': 'int'},
        'sleep_time_for_checking_thrift_job_instance_in_millis': {'key': 'sleepTimeForCheckingThriftJobInstanceInMillis', 'type': 'int'},
        'qstar_download_fingerprint_sampling_ratio': {'key': 'qstarDownloadFingerprintSamplingRatio', 'type': 'float'},
        'generic_retry_count': {'key': 'genericRetryCount', 'type': 'int'},
        'sleep_time_for_checking_thrift_job_instance_in_ms': {'key': 'sleepTimeForCheckingThriftJobInstanceInMs', 'type': 'int'},
        'retry_count_for_fetching_logs_from_bolt_instance': {'key': 'retryCountForFetchingLogsFromBoltInstance', 'type': 'int'},
        'bolt_log_dir': {'key': 'boltLogDir', 'type': 'str'},
        'bolt_log_min_free_space_fraction': {'key': 'boltLogMinFreeSpaceFraction', 'type': 'float'},
        'bolt_log_max_size_in_mb': {'key': 'boltLogMaxSizeInMB', 'type': 'int'},
        'bolt_log_dir_max_size_fraction': {'key': 'boltLogDirMaxSizeFraction', 'type': 'float'},
        'thrift_socket_connection_timeout_in_seconds': {'key': 'thriftSocketConnectionTimeoutInSeconds', 'type': 'int'},
        'thrift_socket_send_timeout_in_seconds': {'key': 'thriftSocketSendTimeoutInSeconds', 'type': 'int'},
        'thrift_socket_receive_timeout_in_seconds': {'key': 'thriftSocketReceiveTimeoutInSeconds', 'type': 'int'},
        'hds_enable_multi_part_upload': {'key': 'hdsEnableMultiPartUpload', 'type': 'bool'},
        'nfs_supported_options': {'key': 'nfsSupportedOptions', 'type': 'str'},
        'nfs_default_options': {'key': 'nfsDefaultOptions', 'type': 'str'},
    }

    def __init__(self, archival_lock_manager_cache_timeout_in_milis=None, azure_upload_stream_size_in_mb=None, use_nfs_upload_in_blocks=None, use_nfs_upload_in_blocks_with_file_channel=None, default_chunk_size_for_encrypted_file_channel_transfer_in_mi_b=None, nfs_upload_stream_size_in_mb=None, ignore_encryption_password_and_create_unencrypted_nfs_location=None, use_qstar_upload_in_blocks=None, qstar_max_thread_count_for_upload=None, qstar_upload_stream_size_in_mb=None, qstar_support_incremental_snapshots=None, use_qstar_web_services_for_status_checks=None, fail_file_accessible_check=None, fail_space_available_check=None, chunk_size_for_encryption_authentication_in_kb=None, threshold_for_uploading_full_in_minutes=None, archival_threshold_multiplier_for_full_upload=None, min_time_for_uploading_full_in_minutes=None, percent_change_rate_for_uploading_full=None, max_full_upload_refs_count=None, min_full_upload_refs_count=None, max_archive_jobs_that_can_run_on_cluster=None, pct_of_full_upload_jobs_per_node=None, force_full_upload_to_archival_store=None, chunk_download_retry_count=None, chunk_download_backoff_initial_range_in_ms=None, ec2_ebs_volume_type=None, ec2_ebs_device_id=None, ec2_ebs_mount_point=None, drop_count_in_archival_bandwidth_query=None, download_snapshot_from_cloud_job_in_memory_sem_shares=None, max_s3_file_size_in_mb=None, max_disk_size_for_cloud_upload_in_gb=None, part_size_for_cloud_upload_in_mb=None, max_part_size_for_cloud_upload_in_mb=None, max_num_parts_for_cloud_upload=None, aws_max_connections_to_s3=None, aws_socket_timeout_in_millis=None, aws_connection_timeout_in_millis=None, aws_connection_max_idle_millis=None, aws_max_retries_for_retryable_errors=None, part_upload_retry_count=None, part_upload_initial_sleep_in_ms=None, ttl_for_ajenkins_test_bucket_in_hours=None, max_download_snapshot_retries=None, archival_key_download_batch_size=None, ec2_image_id=None, ec2_instance_type=None, trust_object_store_tls_certificate_on_first_use=None, tls_protocol_for_private_object_stores=None, initial_heap_size_for_rubrik_bolt_service=None, max_heap_size_for_rubrik_bolt_service=None, allow_list_all_keys_for_gc=None, multi_part_upload_directory=None, sample_fingerprints_to_validate=None, cache_block_size_in_mb=None, archival_service_helper_thrift_timeout_in_seconds=None, non_cacheable_key_ttl_in_seconds=None, retry_for_uploading_sub_object_in_archive_job=None, retry_for_validating_patch_files_after_archive=None, probability_in_percent_to_clear_non_cacheable_keys=None, sub_objects_to_upload_in_parallel=None, sub_objects_to_download_in_parallel=None, validate_fingerprints_after_download=None, exit_archival_recovery_job_cleanly=None, allow_launching_bolt=None, rubrik_bolt_aws_instance_type=None, bolt_cloud_image_prefix=None, recovery_skip_path_verification=None, throttle_wait_time_in_seconds=None, throttle_sleep_time_in_seconds=None, upgrade_required_for_archival_store=None, upgrade_archival_store_frequency_in_minutes=None, cloud_instantiation_job_frequency_in_minutes=None, use_archival_lock_manager_cache=None, upload_percent_disk_space_needed=None, disk_space_reserved_on_archive_for_metadata_in_mb=None, is_private_object_store_out_of_space=None, acceptable_archival_threshold_violation_in_hours=None, aws_s3_apn_user_agent_string=None, archival_location_connectivity_check_frequency_in_minutes=None, sleep_time_for_connectivity_check_in_minutes=None, import_image_wait_time_in_minutes=None, import_image_sleep_time_in_seconds=None, cloud_transient_image_gc_time_in_seconds=None, generic_compute_wait_time_in_seconds=None, generic_compute_sleep_time_in_seconds=None, max_instantiate_job_instances_per_node=None, upload_job_no_work_delay_in_millis=None, cloud_instantiate_delay_in_millis_if_no_archived_snapshot=None, cloud_instantiate_default_image_conversion_frequency_in_seconds=None, cloud_instantiate_default_image_retention_in_seconds=None, instantiate_snapshot_job_retries=None, retry_for_uploading_in_instantiate_job=None, retry_for_converting_to_stream_optimized_vmdk=None, sub_objects_to_convert_for_instantiation_in_parallel=None, ssh_socket_port=None, skip_rubrik_bolt_shut_down_in_cloud_instantation=None, bolt_security_group_id=None, bolt_subnet_id_for_instantiation=None, use_public_ip_for_bolt=None, cloud_storage_service_socket_timeout_in_ms=None, default_chunk_size_to_encrypt_for_archival_in_ki_b=None, bolt_instances_certificates_directory=None, retry_count_for_rubrik_bolt_instance=None, max_cloud_instantiate_jobs_per_bolt=None, delete_cloud_instance_job_retries=None, delete_cloud_image_job_retries=None, use_bolt_for_instantiation=None, bolt_machine_image_id_for_instantiation=None, bolt_cloud_init_script_file_path=None, time_to_wait_for_thrift_job_instance_in_hours=None, sleep_time_for_checking_thrift_job_instance_in_millis=None, qstar_download_fingerprint_sampling_ratio=None, generic_retry_count=None, sleep_time_for_checking_thrift_job_instance_in_ms=None, retry_count_for_fetching_logs_from_bolt_instance=None, bolt_log_dir=None, bolt_log_min_free_space_fraction=None, bolt_log_max_size_in_mb=None, bolt_log_dir_max_size_fraction=None, thrift_socket_connection_timeout_in_seconds=None, thrift_socket_send_timeout_in_seconds=None, thrift_socket_receive_timeout_in_seconds=None, hds_enable_multi_part_upload=None, nfs_supported_options=None, nfs_default_options=None):
        self.archival_lock_manager_cache_timeout_in_milis = archival_lock_manager_cache_timeout_in_milis
        self.azure_upload_stream_size_in_mb = azure_upload_stream_size_in_mb
        self.use_nfs_upload_in_blocks = use_nfs_upload_in_blocks
        self.use_nfs_upload_in_blocks_with_file_channel = use_nfs_upload_in_blocks_with_file_channel
        self.default_chunk_size_for_encrypted_file_channel_transfer_in_mi_b = default_chunk_size_for_encrypted_file_channel_transfer_in_mi_b
        self.nfs_upload_stream_size_in_mb = nfs_upload_stream_size_in_mb
        self.ignore_encryption_password_and_create_unencrypted_nfs_location = ignore_encryption_password_and_create_unencrypted_nfs_location
        self.use_qstar_upload_in_blocks = use_qstar_upload_in_blocks
        self.qstar_max_thread_count_for_upload = qstar_max_thread_count_for_upload
        self.qstar_upload_stream_size_in_mb = qstar_upload_stream_size_in_mb
        self.qstar_support_incremental_snapshots = qstar_support_incremental_snapshots
        self.use_qstar_web_services_for_status_checks = use_qstar_web_services_for_status_checks
        self.fail_file_accessible_check = fail_file_accessible_check
        self.fail_space_available_check = fail_space_available_check
        self.chunk_size_for_encryption_authentication_in_kb = chunk_size_for_encryption_authentication_in_kb
        self.threshold_for_uploading_full_in_minutes = threshold_for_uploading_full_in_minutes
        self.archival_threshold_multiplier_for_full_upload = archival_threshold_multiplier_for_full_upload
        self.min_time_for_uploading_full_in_minutes = min_time_for_uploading_full_in_minutes
        self.percent_change_rate_for_uploading_full = percent_change_rate_for_uploading_full
        self.max_full_upload_refs_count = max_full_upload_refs_count
        self.min_full_upload_refs_count = min_full_upload_refs_count
        self.max_archive_jobs_that_can_run_on_cluster = max_archive_jobs_that_can_run_on_cluster
        self.pct_of_full_upload_jobs_per_node = pct_of_full_upload_jobs_per_node
        self.force_full_upload_to_archival_store = force_full_upload_to_archival_store
        self.chunk_download_retry_count = chunk_download_retry_count
        self.chunk_download_backoff_initial_range_in_ms = chunk_download_backoff_initial_range_in_ms
        self.ec2_ebs_volume_type = ec2_ebs_volume_type
        self.ec2_ebs_device_id = ec2_ebs_device_id
        self.ec2_ebs_mount_point = ec2_ebs_mount_point
        self.drop_count_in_archival_bandwidth_query = drop_count_in_archival_bandwidth_query
        self.download_snapshot_from_cloud_job_in_memory_sem_shares = download_snapshot_from_cloud_job_in_memory_sem_shares
        self.max_s3_file_size_in_mb = max_s3_file_size_in_mb
        self.max_disk_size_for_cloud_upload_in_gb = max_disk_size_for_cloud_upload_in_gb
        self.part_size_for_cloud_upload_in_mb = part_size_for_cloud_upload_in_mb
        self.max_part_size_for_cloud_upload_in_mb = max_part_size_for_cloud_upload_in_mb
        self.max_num_parts_for_cloud_upload = max_num_parts_for_cloud_upload
        self.aws_max_connections_to_s3 = aws_max_connections_to_s3
        self.aws_socket_timeout_in_millis = aws_socket_timeout_in_millis
        self.aws_connection_timeout_in_millis = aws_connection_timeout_in_millis
        self.aws_connection_max_idle_millis = aws_connection_max_idle_millis
        self.aws_max_retries_for_retryable_errors = aws_max_retries_for_retryable_errors
        self.part_upload_retry_count = part_upload_retry_count
        self.part_upload_initial_sleep_in_ms = part_upload_initial_sleep_in_ms
        self.ttl_for_ajenkins_test_bucket_in_hours = ttl_for_ajenkins_test_bucket_in_hours
        self.max_download_snapshot_retries = max_download_snapshot_retries
        self.archival_key_download_batch_size = archival_key_download_batch_size
        self.ec2_image_id = ec2_image_id
        self.ec2_instance_type = ec2_instance_type
        self.trust_object_store_tls_certificate_on_first_use = trust_object_store_tls_certificate_on_first_use
        self.tls_protocol_for_private_object_stores = tls_protocol_for_private_object_stores
        self.initial_heap_size_for_rubrik_bolt_service = initial_heap_size_for_rubrik_bolt_service
        self.max_heap_size_for_rubrik_bolt_service = max_heap_size_for_rubrik_bolt_service
        self.allow_list_all_keys_for_gc = allow_list_all_keys_for_gc
        self.multi_part_upload_directory = multi_part_upload_directory
        self.sample_fingerprints_to_validate = sample_fingerprints_to_validate
        self.cache_block_size_in_mb = cache_block_size_in_mb
        self.archival_service_helper_thrift_timeout_in_seconds = archival_service_helper_thrift_timeout_in_seconds
        self.non_cacheable_key_ttl_in_seconds = non_cacheable_key_ttl_in_seconds
        self.retry_for_uploading_sub_object_in_archive_job = retry_for_uploading_sub_object_in_archive_job
        self.retry_for_validating_patch_files_after_archive = retry_for_validating_patch_files_after_archive
        self.probability_in_percent_to_clear_non_cacheable_keys = probability_in_percent_to_clear_non_cacheable_keys
        self.sub_objects_to_upload_in_parallel = sub_objects_to_upload_in_parallel
        self.sub_objects_to_download_in_parallel = sub_objects_to_download_in_parallel
        self.validate_fingerprints_after_download = validate_fingerprints_after_download
        self.exit_archival_recovery_job_cleanly = exit_archival_recovery_job_cleanly
        self.allow_launching_bolt = allow_launching_bolt
        self.rubrik_bolt_aws_instance_type = rubrik_bolt_aws_instance_type
        self.bolt_cloud_image_prefix = bolt_cloud_image_prefix
        self.recovery_skip_path_verification = recovery_skip_path_verification
        self.throttle_wait_time_in_seconds = throttle_wait_time_in_seconds
        self.throttle_sleep_time_in_seconds = throttle_sleep_time_in_seconds
        self.upgrade_required_for_archival_store = upgrade_required_for_archival_store
        self.upgrade_archival_store_frequency_in_minutes = upgrade_archival_store_frequency_in_minutes
        self.cloud_instantiation_job_frequency_in_minutes = cloud_instantiation_job_frequency_in_minutes
        self.use_archival_lock_manager_cache = use_archival_lock_manager_cache
        self.upload_percent_disk_space_needed = upload_percent_disk_space_needed
        self.disk_space_reserved_on_archive_for_metadata_in_mb = disk_space_reserved_on_archive_for_metadata_in_mb
        self.is_private_object_store_out_of_space = is_private_object_store_out_of_space
        self.acceptable_archival_threshold_violation_in_hours = acceptable_archival_threshold_violation_in_hours
        self.aws_s3_apn_user_agent_string = aws_s3_apn_user_agent_string
        self.archival_location_connectivity_check_frequency_in_minutes = archival_location_connectivity_check_frequency_in_minutes
        self.sleep_time_for_connectivity_check_in_minutes = sleep_time_for_connectivity_check_in_minutes
        self.import_image_wait_time_in_minutes = import_image_wait_time_in_minutes
        self.import_image_sleep_time_in_seconds = import_image_sleep_time_in_seconds
        self.cloud_transient_image_gc_time_in_seconds = cloud_transient_image_gc_time_in_seconds
        self.generic_compute_wait_time_in_seconds = generic_compute_wait_time_in_seconds
        self.generic_compute_sleep_time_in_seconds = generic_compute_sleep_time_in_seconds
        self.max_instantiate_job_instances_per_node = max_instantiate_job_instances_per_node
        self.upload_job_no_work_delay_in_millis = upload_job_no_work_delay_in_millis
        self.cloud_instantiate_delay_in_millis_if_no_archived_snapshot = cloud_instantiate_delay_in_millis_if_no_archived_snapshot
        self.cloud_instantiate_default_image_conversion_frequency_in_seconds = cloud_instantiate_default_image_conversion_frequency_in_seconds
        self.cloud_instantiate_default_image_retention_in_seconds = cloud_instantiate_default_image_retention_in_seconds
        self.instantiate_snapshot_job_retries = instantiate_snapshot_job_retries
        self.retry_for_uploading_in_instantiate_job = retry_for_uploading_in_instantiate_job
        self.retry_for_converting_to_stream_optimized_vmdk = retry_for_converting_to_stream_optimized_vmdk
        self.sub_objects_to_convert_for_instantiation_in_parallel = sub_objects_to_convert_for_instantiation_in_parallel
        self.ssh_socket_port = ssh_socket_port
        self.skip_rubrik_bolt_shut_down_in_cloud_instantation = skip_rubrik_bolt_shut_down_in_cloud_instantation
        self.bolt_security_group_id = bolt_security_group_id
        self.bolt_subnet_id_for_instantiation = bolt_subnet_id_for_instantiation
        self.use_public_ip_for_bolt = use_public_ip_for_bolt
        self.cloud_storage_service_socket_timeout_in_ms = cloud_storage_service_socket_timeout_in_ms
        self.default_chunk_size_to_encrypt_for_archival_in_ki_b = default_chunk_size_to_encrypt_for_archival_in_ki_b
        self.bolt_instances_certificates_directory = bolt_instances_certificates_directory
        self.retry_count_for_rubrik_bolt_instance = retry_count_for_rubrik_bolt_instance
        self.max_cloud_instantiate_jobs_per_bolt = max_cloud_instantiate_jobs_per_bolt
        self.delete_cloud_instance_job_retries = delete_cloud_instance_job_retries
        self.delete_cloud_image_job_retries = delete_cloud_image_job_retries
        self.use_bolt_for_instantiation = use_bolt_for_instantiation
        self.bolt_machine_image_id_for_instantiation = bolt_machine_image_id_for_instantiation
        self.bolt_cloud_init_script_file_path = bolt_cloud_init_script_file_path
        self.time_to_wait_for_thrift_job_instance_in_hours = time_to_wait_for_thrift_job_instance_in_hours
        self.sleep_time_for_checking_thrift_job_instance_in_millis = sleep_time_for_checking_thrift_job_instance_in_millis
        self.qstar_download_fingerprint_sampling_ratio = qstar_download_fingerprint_sampling_ratio
        self.generic_retry_count = generic_retry_count
        self.sleep_time_for_checking_thrift_job_instance_in_ms = sleep_time_for_checking_thrift_job_instance_in_ms
        self.retry_count_for_fetching_logs_from_bolt_instance = retry_count_for_fetching_logs_from_bolt_instance
        self.bolt_log_dir = bolt_log_dir
        self.bolt_log_min_free_space_fraction = bolt_log_min_free_space_fraction
        self.bolt_log_max_size_in_mb = bolt_log_max_size_in_mb
        self.bolt_log_dir_max_size_fraction = bolt_log_dir_max_size_fraction
        self.thrift_socket_connection_timeout_in_seconds = thrift_socket_connection_timeout_in_seconds
        self.thrift_socket_send_timeout_in_seconds = thrift_socket_send_timeout_in_seconds
        self.thrift_socket_receive_timeout_in_seconds = thrift_socket_receive_timeout_in_seconds
        self.hds_enable_multi_part_upload = hds_enable_multi_part_upload
        self.nfs_supported_options = nfs_supported_options
        self.nfs_default_options = nfs_default_options
