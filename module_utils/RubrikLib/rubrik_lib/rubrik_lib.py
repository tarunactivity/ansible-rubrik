# coding=utf-8
# --------------------------------------------------------------------------
# Code generated by Microsoft (R) AutoRest Code Generator.
# Changes may cause incorrect behavior and will be lost if the code is
# regenerated.
# --------------------------------------------------------------------------

from msrest.service_client import ServiceClient
from msrest import Configuration, Serializer, Deserializer
from .version import VERSION
from msrest.pipeline import ClientRawResponse
from msrest.exceptions import HttpOperationError
from . import models


class RubrikLibConfiguration(Configuration):
    """Configuration for RubrikLib
    Note that all parameters used to create this instance are saved as instance
    attributes.

    :param str base_url: Service URL
    """

    def __init__(
            self, base_url=None):

        if not base_url:
            base_url = 'https://localhost/api'

        super(RubrikLibConfiguration, self).__init__(base_url)

        self.add_user_agent('rubriklib/{}'.format(VERSION))


class RubrikLib(object):
    """
    Copyright © 2017 Rubrik Inc. [Legal](#section/Legal)
    # Introduction
    Welcome to the Rubrik™ REST API documentation.
    The Rubrik REST API provides a RESTful interface for working with Rubrik clusters and Rubrik Edge virtual appliances. The Rubrik REST API can be used to query, configure, and control nearly all of the operations of the Rubrik software.
    Through authenticated and encrypted interaction with the Rubrik REST API server, perform any of the operations that are available through the Rubrik web UI and many bulk-type operations that might otherwise be difficult or impossible to perform.
    This documentation provides reference information and examples of typical workflows for the Rubrik REST API. For more detailed information about working with Rubrik clusters and Rubrik Edge virtual appliances refer to the *Rubrik User Guide*.
    A quick way to become familiar with the Rubrik REST API, is to use the Rubrik REST API Explorer. [OpenAPI](#section/OpenAPI) describes this tool.
    Refer to the [changelog](#section/Changelog) to see information about changes within this version of the Rubrik REST API.
    # Changelog
     Revisions are listed with the most recent revision first.
     ### Changes to V1 API in Rubrik version 4.0.0
     New features:
     * Added a new field 'name' on GET /sla_domain. This allows users to search
       SLA Domains by name. Users can also sort the SLA Domain summary results
       in ascending/descending order by name
     * The Rubrik cluster generates a unique ID for each virtual machine when a
       vCenter Server is added. When a virtual machine changes to another vCenter
       Server or unregisters and registers with the same vCenter Server, a new
       unique ID is generated for that virtual machine. When this happens, the
       virtual machine object associated with the original ID becomes a relic.
       In this release we have added the option conflictResolutionAuthz to
       add/edit vCenter endpoints of the Rubrik REST APIs. This option can take
       either 'AllowAutoConflictResolution' to authorize the linking of relic
       virtual machine objects with the current virtual machine object of a
       specific virtual machine, and makes the collective snapshot history
       available through the current object. Or it can take 'NoConflictResolution'
       to not allow linking. Default value is 'NoConflictResolution'.
     * Introduced endpoints for SQL Server Live Mounts: POST /mssql/db/{id}/mount,
       GET /mssql/db/mount, GET /mssql/db/mount/{id}, and
       DELETE /mssql/db/mount/{id}. These allow users to create, query for, and
       delete Live Mounts for SQL Server databases.
     * Added the isLiveMount field to the response of GET /mssql/db. Added an
       optional is_live_mount query parameter to filter by this field.
     * Added links field to the paginated responses of
       GET /vmware/vm, /vmware/vm/mount and /fileset endpoints. This allows users to navigate between pages by following the href in links.prev and links.next.
     * Introduced optional caCerts parameter for the vCenter post/put/patch
       endpoints to specify trusted CA certs to use when connecting to a vCenter
       server and associated ESX hosts.
     * Modified PATCH /mssql/instance/{id} endpoint to support SQL db
       auto-protection, added fields configuredSlaDomainId,
       logBackupFrequencyInSeconds, logRetentionHours, and copyOnly to the PATCH
       request, as well as configuredSlaDomainId, configuredSlaDomainName,
       logBackupFrequencyInSeconds, logRetentionHours, and copyOnly to the GET and
       PATCH responses.
     * Added GET /vmware/vcenter/{id} endpoint to allow fetching details of a
       single vCenter server, including its refresh and delete status.
     * Introduced optional parameter keepMacAddresses to
       POST /vmware/vm/snapshot/{id}/mount, /vmware/vm/snapshot/{id}/export, and
       /v1/vmware/vm/snapshot/{id}/instant_recovery endpints.
       This allows new VMs to have the same MAC address as their source VMs.
     * Introduced optional parameters offset and limit to support
       pagination for Browse end-point.
     * Added a field 'cloudInstantiationSpec' on GET /vmware/vm and PATCH
     /v1/vmware/vm/{id} to allow enabling/disabling/updating specs for automatic
       conversion to cloud image on a per VM basis
     ### Changes to V1 API in Rubrik version 3.2.0
     New features:
     * Added an option to preserve the virtual machine moid during instant recovery.
       Use this option cautiously. It will permanently overwrite the source
       virtual machine. The source virtual machine cannot be recovered if the
       operation fails. It will not create a new virtual machine and rename
       the original one so we could fall back to the original in case of a failure
       in the process. This is not exposed in the Web UI and the API user should
       be careful to not destroy the original virtual machine by accident.
     * Introduced shareId into /fileset endpoints to support
       the creation of filesets based on network shares.
     * Introduced optional config parameter for all on demand
       snapshot endpoints. The config parameter includes an optional slaId field.
       The policies of the specified SLA Domain determine the retention of backups
       on the local Rubrik cluster, the retention target, and the archival location.
     * Introduced optional parameters to endpoint /mssql/db/{id}/export,
       so that physical filenames and logical filenames can be changed
       for exported databases. These two parameters are newFilename and
       newLogicalName.
     * Introduced optional config parameter for the VM patch endpoint
       (PATCH /vmware/vm/{id}) to specify a guest credential for a
       specific VM.
     * Introduced optional query parameters to endpoint /host, to
       support infix searching by hostname and sort order of results.
     * Introduced slaId and slaName field to all snapshot summary/details object.
       These fields specify the SLA Domain object that is associated with the
       snapshot.
    Bug Fixes:
     * Made path parameter required in GET /fileset/snapshot/{id}/browse
       and GET /vmware/vm/snapshot/{id}/browse. Previously, an error was
       thrown when path wasn't passed in. This solves that bug.
     ### Changes to V1 API in Rubrik version 3.1.0
     Initial GA release
    # Overview #
    The Rubrik REST API provides a means to work with Rubrik clusters and Rubrik Edge virtual appliances using text-based representations of the resource objects that are managed by the Rubrik software.
    In its simplest form, the RESTful architecture used by the Rubrik REST API has the following workflow:
    1. Client authenticates with the Rubrik REST API server and starts a session.
    2. Client sends an HTTP request to the URI for a resource object.
    3. Server handles the request and sends an HTTP response with a JSON formatted response body.
    This overview section provides a basic description of the HTTP requests and responses used with the Rubrik REST API. The [Authentication](#section/Authentication) section provides information about how a client authenticates with the Rubrik REST API server.
    ## Documentation conventions
    The descriptions in this documentation use 'Rubrik cluster' to refer to both Rubrik clusters and Rubrik Edge virtual appliances.
    The documentation uses a dollar symbol to indicate a variable in body text and code samples. Some examples:
    * `$cluster_address` to represent a Rubrik cluster IP or resolvable host name
    * `$snapshot_id` to represent the ID of a specific snapshot
    * `$request_id` to represent the ID of a specific asynchronous request
    To shorten the path shown in a code sample, the documentation sometimes replaces a longer variable form with the variable form `{id}`. This variable form represents the `id` value for an associated member string in a response body or request URL.
    The documentation use the term 'snappable' to refer to all objects that have data that can be protected by a Rubrik cluster or a Rubrik Edge appliance. For example, all of the following are 'snappables':
    * Virtual machines
    * File systems
    * SQL Server databases
    ## Versioning
    The Rubrik REST API structures the request URL to include the version of the API. This ensures that backwards incompatible improvements in a new version are not unintentionally used with an earlier version of the API.
    The URL of a request includes a segment that identifies the version of the API. In the URL, the version segment always follows immediately after the Rubrik REST API server name or IPv4 address.
    For example, for a Rubrik cluster with the server address `$cluster_address` a request to the cluster endpoint for Rubrik REST API v1 would look like this:
    `https://$cluster_address/api/v1/cluster`
    In this URL, the `v1` represents the version number for Rubrik REST API v1.
    The Rubrik REST API increments the version number when the new version includes a change that is not backward compatible.
    Examples of changes that are not backward compatible include:
    * Resource type removed
    * Required parameter added to an existing resource type
    * Required parameter removed from an existing resource type
    * Renamed resource or parameter
    * Authentication requirement added for a previously unauthenticated resource
    When the Rubrik REST API has changes that are not backward compatible, those changes appear in a new version. For example, incompatible changes to v1 appear in v2. The Rubrik REST API server makes v2 endpoints available on the path: `https://$cluster_address/api/v2/`. The Rubrik REST API server continues to provide the v1 endpoints on the path: `https://$cluster_address/api/v1/`.
    ### Changes within a version
    Backward compatible changes can be added to the Rubrik REST API as part of an update of the Rubrik CDM software on a Rubrik cluster or Rubrik Edge appliance. When this occurs, the version number remains the same and the URL segment that identifies the API version does not change. The [Changelog](#section/Changelog) that is provided in the docs for each version of the Rubrik REST API describes the changes that are made within that version.
    Examples of backward compatible changes include:
    * New API resource added
    * New optional request parameters added to existing resources
    * New properties added to existing responses
    ## Architecture
    The Rubrik REST API architecture centers around logical entities called *resource objects*. Resource objects can be discrete entities or can contain a hierarchy of other, dependent, resource objects. A dependent, or child, resource object is referenced through the parent object.
    For example, a virtualization environment is a resource object that contains virtual machines as child resource objects. The virtual machines, in turn, contain snapshots as child resource objects. To address this hierarchy, the path to a snapshot must include the parent objects.
    As shown here those parent objects are the virtualization environment (`vmware`) and the virtual machine (`vm`): `/vmware/vm/snapshot`.
    When a request addresses a specific resource object the path must include the  `id` of that specific object.
    For example, to address a specific snapshot with the `id` value of `123-456` the path would be: `/vmware/vm/snapshot/123-456`.
    The full URL for the request would be: `https://$cluster_address/api/v1/vmware/vm/snapshot/123-456`
    The path in this example points to a specific snapshot with the `id` value of `123-456`.
    The `id` is an opaque value which is generated by the Rubrik REST API. It does not follow any specific format.
    ### API base path
    Each endpoint in the Rubrik REST API exists on one of two possible base paths:
    * `https://$cluster_address/api/v1/`
    * `https://$cluster_address/api/internal/`
    The `/api/v1` base path provides the most commonly used endpoints. Rubrik considers these endpoints to be stable. Rubrik designs new releases of the Rubrik REST API to provide as much backward compatibility for these endpoints as possible. After an upgrade to a new version of the Rubrik CDM software, or to a new version of the Rubrik REST API, existing calls to endpoints on the `/api/v1` base path will normally continue to work.
    The primary purpose of the `/api/internal` base path is to provide endpoints that are used by the Rubrik cluster. These endpoints are *internal* in the sense that the Rubrik CDM software uses them to provide a wide variety of cloud data management features. The evolution and improvement of the Rubrik CDM software can cause changes to these endpoints, removal of these endpoints, or addition of new `/api/internal` endpoints. Rubrik does not attempt to make the `/api/internal` endpoints backward compatible.
    ### Requests
    To perform a task, the Rubrik REST API uses an HTTP request. Most requests perform one of these actions:
    * Get an instance of an object from a list
    * Add an instance of an object to a list
    * Perform an operation on an object using the `id` of the object.
    The following table describes the HTTP method and endpoint excerpts for some typical HTTP requests.
    **Note:** The endpoints shown here would be appended to the base URL: `https://$cluster_address/vmware`.
    | Method | Endpoint | Description |
    | ------ | --- | ----------- |
    | GET | `/vm/snapshot` | Returns a list of snapshots. |
    | POST | `/vm/snapshot` | Creates a new snapshot resource object. |
    | GET | `/vm/snapshot/{id}` | Returns information about the snapshot that is identified by `id`. |
    | PATCH | `/vm/snapshot/mount/{id}` | Changes the power status of the mounted snapshot that is identified by `id`. |
    | PUT | `/vcenter/{id}` | Provides a request body with a complete update of the properties of the vCenter Server object that is identified by `id`. |
    | DELETE | `/vm/snapshot/{id}` | Deletes the snapshot that is identified by `id`. |
    | GET | `/vm/{id}/missed_snapshot` | Returns the value of `missed_snapshot` for a snapshot that is identified by `id`. |
    | POST | `/vm/snapshot/{id}/mount` | Performs a `mount` operation using the snapshot that is identified by `id`. |
    #### Reserved ID alias
    The alias `me` can be used with some endpoints as a shorthand replacement for the current, or local, value of that resource object type. For example, for the resource object type `/cluster` the alias `me` can be substituted for the `id` of the Rubrik cluster that is hosting the current session. For the resource object type `/session` the alias `me` can be substituted for the `id` of the current session.
    In filters, use the alias `local` to refer to the Rubrik cluster that is hosting the current session.
    #### Timestamp
    The Rubrik REST API uses a timestamp to express all time values. The timestamp meets the standards of ISO 8601 and uses Coordinated Universal Time (UTC). Timestamps take the form: YYYY-MM-DDTHH:MM:SSZ, with YYYY for the four digit year value, MM for the two digit month value, DD for the two digit day of the month value, HH for the two digit hour value using a 24-hour clock, MM for the two digit minute value, and SS for the two digit second value. The T stands for time and the Z stands for Zulu time, another name for UTC.
    **Example:** Timestamp in a JSON-formatted response body
    ```bash
    {
      "createdTimestamp": "2016-02-11T18:02:24Z"
    }
    ```
    ### Responses
    The Rubrik REST API server responds to all requests by sending an HTTP response message. The response contains a status code and, when appropriate, a JSON object in the response body.
    #### Status codes
    The Rubrik REST API server includes an HTTP status code with every response. The following table describes the status codes supported by the Rubrik REST API server.
    | Status code | Description |
    | ----------- | ----------- |
    | 200&amp;nbsp;OK | Request succeeded. Not used for a DELETE request, or for a POST request that creates a resource. |
    | 201&amp;nbsp;Created | POST request to create a resource object succeeded. |
    | 202&amp;nbsp;Accepted | Request was successfully accepted for further processing. |
    | 204&amp;nbsp;No&amp;nbsp;Content | Request succeeded and the response body is empty. Used for successful DELETE requests and for successful POST requests that do not return content. |
    | 400&amp;nbsp;Bad&amp;nbsp;Request | Request failed because it was malformed. The request may be garbled, or it may be missing required parameters. |
    | 401&amp;nbsp;Unauthorized | The requestor has insufficient authorization to perform the requested action. |
    | 403&amp;nbsp;Forbidden | The requested action is blocked in the current context. |
    | 404&amp;nbsp;Not&amp;nbsp;Found | The request references a resource object that is unknown to the Rubrik REST API server. |
    | 415&amp;nbsp;Unsupported Media Type | The HTTP header of the request specifies a media type that is not supported by the Rubrik REST API server. |
    | 422&amp;nbsp;Unprocessable Entity | The request specifies a correct media type and contains correct syntax but cannot be processed because of semantical errors. |
    | 500&amp;nbsp;Internal Server Error | The Rubrik REST API server encountered an unhandled error. |
    | 503&amp;nbsp;Service Unavailable Error | The Rubrik REST API server is temporarily unavailable. |
    #### Response body
    The JSON object included in a response body can contain members (`{string : value}`) and arrays (`[elements]`). Also, members and arrays can be nested within members and arrays.
    When a response includes a resource object, the object always includes an `id` member in the form `id : $id`. The value of the `id` member is the unique ID of the resource.
    When a response includes a large array (or list) of elements, the Rubrik REST API server encloses the array in a `ListResponse` structure. The `ListResponse` structure breaks a lengthy array into 'pages' of information to make the information easier to manage. Refer to 'Working with lists' for information about managing arrays with large numbers of values.
    #### Status code 400 responses
    The Rubrik REST API server sends a response containing the HTTP status code '400 Bad Request' when the server cannot process the request. This can be caused by malformed request syntax, invalid request message framing, or deceptive request routing.
    The Rubrik REST API server returns a '400 Bad Request' when:
    * Request does not conform with the format specified in OpenAPI definition files. For example, the request is missing required fields.
    * Request is malformed. For example, the request has a malformed `id`.
    * Request contains unsupported `enum` values.
    #### Status code 422 responses
    The Rubrik REST API server sends a response containing the HTTP status code '422 Unproccessable entity' when the request is syntactically correct but has semantic errors.
    For example, when a request refers to an archival location that is not available. Although the request is properly formed, the Rubrik REST API server cannot act on the request because of the missing archival location, and the server returns '422 Unproccessable entity'.
    The Rubrik REST API server also returns '422 Unproccessable entity' when invalid credentials are submitted during login. In that situation, the request may be correctly formed but the action cannot be completed by using the supplied values.
    The following table describes the members of a '422 Unproccessable entity' response object.
    | Member | Optional | Description |
    | ------ | --- | ----------- |
    | `type` | No | Error category. Possible values include: vcenter_error, oracle_error, rubrik_error |
    | `message` | No | Plain text explanation of the cause of the error. |
    | `code` | Yes | A short text string representing the cause of the error. |
    | `param` | Yes | The request member that is the source of the error, such as `backup_window`. |
    ## Working with lists
    When a request returns a large list of elements, the response array can be encapsulated within a `ListResponse` object. The `ListResponse` object is a pagination structure for the elements in the response array. The `ListResponse` object allows the response array to be addressed through smaller subsets of the array, or 'pages'.
    To work with a `ListResponse` object, form a request that calls for a specific page of the results by specifying an offset value and a limit. The response includes the elements from the list starting at the offset value and continuing to the limit. When the limit is very large, or unspecified, the Rubrik REST API server returns as many elements as can be handled by the available memory.
    The `ListResponse` object consists of the members described in the following table.
    | Member | Optional | Description |
    | ------ | --- | ----------- |
    | `hasMore` | No | Indicates whether the array contains elements that are not provided by the current response. `true` if more elements are available for the original request and `false` if the last element is in the current response. |
    | `data` | No | An array of the requested elements. Can be all or some of the elements requested. The elements can be members, arrays, or objects. |
    | `total` | Yes | Total number of elements. |
    | `links` | Yes | When `hasMore` is true, provides a request URL for the next page of results. When appropriate, also provides a request URL for the previous page of results. The request URLs provided by `links` retain the query parameters from the original request. For example, a request URL would retain a value specified by `limit` and a value specified by `search`. The exception to this is the value specified by `offset`, which the Rubrik REST API server uses to specify next and previous pages. |
    Control the contents of a `ListResponse` object by including the following optional query parameters with the original request:
    * `limit`
    Defines the maximum number of a elements to include in the `data` array of the response. Available memory may prevent the return of all elements for very large `limit` values. When that occurs, the response includes `"hasMore": true`.
    * `offset`
    Index reference point to use when determining the elements to include in a response. Include the next element after the index number specified by `offset`. The default value is `0`, which means the list page that is provided in the response starts with first element in the list.
    For example, if the total number of elements in response to a query are 100, and the request includes the following query parameters: `limit=10` and `offset=30`, then the response will include a list page with elements 31-40.
    When the `ListResponse` object provides `next` and `prev`, use the URL specified by `next` to request the next page of elements or use the URL specified by `prev` to request the previous page of elements.
    **Example:** Request for all snapshots from a Rubrik cluster
    The initial request uses the query parameter `limit=1`.
    ```bash
    curl -X GET "https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1"
    ```
    The response returns the first element and `"hasMore": true` indicates that more than one snapshot meets the request.
    ```bash
    {
      "hasMore": true,
      "status": "RUNNING",
      "data": [
        {
          "id": "1",
          "name": "Windows2012"
        }
      ],
      "links": {
        "next": {
          "href": "https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&amp;offset=1"
        }
      }
    }
    ```
    To obtain the next element, the request is reissued with the query parameters set to: `limit=1&amp;offset=1`. This could also be achieved by using the URL specified by `next` to request the next page.
    ```bash
    curl -X GET "https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&amp;offset=1"
    ```
    The response returns the second element in the array. Since there are elements before and after the element in the response, the `links` member contains both a `next` request URL and a `prev` request URL.
    ```bash
    {
      "hasMore": false,
      "status": "RUNNING",
      "data": [
        {
          "id": "2",
          "name": "Windows2016"
        }
      ],
      "links": {
        "prev": {
           "href": "https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&amp;offset=0",
          "rel": "prev"
        },
        "next": {
          "href": "https://$cluster_address/api/v1/vmware/vm/snapshot?limit=1&amp;offset=2",
          "rel": "next"
        }
      }
    }
    ```
    ## Asynchronous requests
    The Rubrik REST API server uses asynchronous (async) API requests for tasks that take longer to run. By using async requests the Rubrik REST API server avoids blocking the requestor from performing other tasks while the async tasks run.
    The response to an async request includes a task object in the response body. The following table describes the members of a task object.
    | Member | Optional | Description |
    | ------ | --- | ----------- |
    | `id` | No |  ID assigned to the task.  |
    | `status` | No |  Status of the task: 'RUNNING', 'SUCCEEDED', 'CANCELLED', or 'FAILED'.   |
    | `error` | No | Message describing reason for cancelled or failed task, or 'None'. |
    | `startTime` | Yes | Timestamp when the Rubrik cluster schedules the task. |
    | `endTime` | Yes | Timestamp when the task ends. |
    | `progress` | Yes | Percentage of the task that is complete. |
    | `links` | No | Polling request array that provides information about how to poll the task. |
    The following table describes the polling request array in the `links` member.
    | Member | Optional | Description |
    | ------ | --- | ----------- |
    | `href` | No | URL to send requests to when polling the task. |
    | `rel` | No | Provides a value of 'self' to indicate that the array refers to the resource represented by the parent JSON object. |
    When an async task is completed the Rubrik REST API server adds a second array to the `links` member in the response that is sent. The second array provides information about how to request the result of the async task.
    The following table describes the results array in the `links` member.
    | Member | Optional | Description |
    | ------ | --- | ----------- |
    | `href` | No | URL to send a request to for the result of the task. |
    | `rel` | No | Provides a value of 'result' to indicate that the array refers to the resource represented by the parent JSON object. |
    **Example:** Starting a mount task and polling the task status
    To initiate a mount operation, send a POST request to the mount endpoint. Include an object containing the details of the snapshot.
    ```bash
    curl -X POST "https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/mount"
    ```
    The Rubrik REST API server returns a task object for the mount operation. The task object describes the task status as 'RUNNING' and provides the `links` member which contains the polling request array.
    ```bash
    {
      "id": "$request_id",
      "status": "RUNNING",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/vmware/vm/request/$request_id",
          "rel": "self"
        }
      ]
    }
    ```
    Using the information provided in the task object, send a GET request to poll the task status.
    ```bash
    curl -X GET "https://$cluster_address/api/v1/vmware/vm/request/$request_id"
    ```
    ```bash
    {
      "id": "$request_id",
      "status": "RUNNING",
      "error": "None",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/vmware/vm/request/$request_id",
          "rel": "self"
        }
      ]
    }
    ```
    Continue to poll the task object until the status changes to 'SUCCEEDED'.
    ```bash
    curl -X GET "https://$cluster_address/api/v1/vmware/vm/request/$request_id"
    ```
    When the task object status changes to 'SUCCEEDED', the `links` member of the request includes a results array that provides a URL for the task results.
    ```bash
    {
      "id": "$request_id",
      "status": "SUCCEEDED",
      "error": "None",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/vmware/vm/request/$request_id",
          "rel": "self"
        },
        {
          "href": "https://$cluster_address/api/v1/vmware/vm/$mounted_vm_id",
          "rel": "result"
        }
      ]
    }
    ```
    # OpenAPI
    The Rubrik REST API specification conforms to the OpenAPI 2.0 Specification. Tools that work with the OpenAPI 2.0 Specification can be used with the Rubrik REST API specification.
    Development releases (pre-1.0) of the Rubrik REST API specification made reference to 'swagger'. The previous release of the OpenAPI 2.0 Specification was named the Swagger 1.2 Specification.
    Download the Rubrik REST API specification for your tools. [Download](./api-docs)
    ## Rubrik REST API Explorer
    The Rubrik REST API Explorer is a browser-based API client hosted by the Rubrik cluster. The Explorer has the Rubrik REST API specification built in. You can use the Explorer to try out Rubrik REST API calls and view the responses.
    **IMPORTANT:** The Explorer interacts with the Rubrik cluster through the API calls you make. Use care when making calls that modify or delete configurations and data.
    To access the Rubrik REST API Explorer, click: [Rubrik REST API Explorer](./playground/)
    # Authentication
    The Rubrik REST API server requires that all API calls use the HTTPS protocol.
    To meet the security requirements of that protocol, the Rubrik REST API server uses a self-signed certificate.
    A self-signed certificate cannot be validated through a Certificate Authority. Client tools must be configured to ignore the certificate validation error.
    The Rubrik REST API server requires authentication and authorization for each API call, except calls made to the following endpoints:
    * [/cluster/me/version](#operation/getClusterVersion)
    * [/cluster/me/api_version](#operation/getClusterApiVersion)
    Rubrik REST API server authenticates a session using either of the following methods:
    * BasicAuth
    * Token
    For both methods, the Rubrik REST API server requires that you use an existing username/password for the Rubrik cluster.
    ## BasicAuth authentication
    BasicAuth authentication uses the HTTP Basic Authentication method and requires you to include the user credentials with each API call. Since each API call made using the BasicAuth method is separately authenticated, you do not need to manage the session state. You also do not need to log out of a session, since this method does not create a session.
    To use the BasicAuth method, provide the user credentials in the 'Authorization' header of an API call.
    Use the string `Basic` followed by the Base64 encoding of `&lt;username:password&gt;`as the user credentials, where `&lt;username:password&gt;` is the username for an Admin account on the host Rubrik cluster, a colon, and the account password.
    **Example:** Using curl to retrieve a session ID
    This example uses the local Admin username 'admin' and the password 'pass' to retrieve: a session ID, the Rubrik server software version, and the API version.
    The curl command shown here takes `&lt;username:password&gt;`, adds 'Basic ' to the string, and Base64 encodes the result.
     The command includes the following arguments:
     * `-k` to bypass an alert about the self-signed certificate
     * `-u` to flag the `&lt;username:password&gt;` string
     * `-X` to flag the HTTP method `GET`
    ```bash
    curl -k -u admin:pass -X GET "https://$cluster_address/api/v1/cluster/me"
    ```
    The Rubrik REST API server returns the following response body.
    ```bash
    {
      "id": "$cluster_id",
      "version": "3.1.0",
      "apiVersion": "1.0"
    }
    ```
    ## Token authentication
    Token authentication creates a token at the beginning of a session and then uses that token to authenticate the API calls that are made during the session.
    The token remains valid for the session - normally 30 minutes after the last activity.
    You can close a session and invalidate the session token at any time by making a DELETE call to `/session/{id}` where `{id}` is the session ID or `me` for the current session ID.
    **Example:** Token authentication in a session
    This example uses the local Admin username 'admin' and the password 'pass'. To open a session, first use the [BasicAuth](#section/BasicAuth) method to authenticate a POST call to [/session](#operation/createSession).
    ```bash
    curl -k -u admin:pass -X POST "https://$cluster_address/api/v1/session"
    ```
    The response body includes an array with the session token.
    ```bash
    {
      "id": "$session_id",
      "token": "$token_id",
      "userId": "$user_id"
    }
    ```
    For all subsequent calls during the session, include the token in the Authorization header using the form: `Authorization: Bearer $token_id` where `$token_id` is the value of the `token` member from the response array.
    In this curl command, the GET request to [/cluster](#operation/getPublicClusterInfo) uses `-H` to provide the `Authorization: Bearer $token_id` value.
    ```bash
    curl -k -H "Authorization: Bearer $token_id" -X GET "https://$cluster_address/api/v1/cluster/me"
    ```
    The response body contains an array with the session ID, the Rubrik cluster software version, and the API version.
    ```bash
    {
      "id": "$cluster_id",
      "version": "3.1.0",
      "apiVersion": "1.0"
    }
    ```
    To close the session and invalidate the session token, make a DELETE call to [/session](#operation/deleteSession) using the value of the `id` key or use `me`. The alias `me` represents the session specified in the Authorization header.
    ```bash
    curl -k -H "Authorization: Bearer $token_id" -X DELETE "https://$cluster_address/api/v1/session/me"
    ```
    # SLA Domains
    Rubrik clusters provide automated data management and protection through SLA Domains.
    An SLA Domain defines the data management and protection policies for their assigned snappables (virtual machines, file systems, and applications).
    To provide policy based management and protection of a snappable, add the snappable to an SLA Domain, or to multiple SLA Domains.
    ## Retrieving SLA Domains
    Before assigning snappables to SLA Domains, get a list of the SLA Domains that exist on a Rubrik cluster. For a new Rubrik cluster, the list shows only the default SLA Domains. When custom SLA Domains are added to the Rubrik cluster, the list is modified to include those SLA Domains.
    **Example:** Retrieving SLA Domains from a Rubrik cluster
    Send a GET request to [`/sla_domain`](#operation/querySlaDomain).
    ```bash
    curl -X GET "https://$cluster_address/api/v1/sla_domain"
    ```
    The Rubrik REST API server returns a `ListResponse` object of all SLA Domains.
    At a minimum, the `ListResponse` object includes the default SLA Domains: Gold, Silver, and Bronze.
    ```bash
    {
      "data": [
        {
          "id": "$gold_sla_id",
          "name": "Gold"
        },
        {
          "id": "$silver_sla_id",
          "name": "Silver"
        },
        {
          "id": "$bronze_sla_id",
          "name": "Bronze"
        }
      ],
      "hasMore": false,
      "total": 3
    }
    ```
    To obtain more details about a specific SLA domain send a GET request with the `id` of one of the SLA Domains to the `/sla_domain/{id}` endpoint:  [`/sla_domain/{id}`](#operation/getSlaDomain)
    ```bash
    curl -X GET "https://$cluster_address/api/v1/sla_domain/$bronze_sla_id"
    ```
    The Rubrik REST API server responds with the details of the specified SLA Domain.
    ```bash
    {
      "id": "$bronze_sla_id",
      "primaryClusterId": "$cluster_id",
      "name": "Bronze",
      "frequencies": [
        {
          "timeUnit": "Daily",
          "frequency": 1,
          "retention": 32
        },
        {
          "timeUnit": "Monthly",
          "frequency": 1,
          "retention": 12
        },
        {
          "timeUnit": "Yearly",
          "frequency": 1,
          "retention": 2
        }
      ],
      "allowedBackupWindows": [],
      "firstFullAllowedBackupWindows": [],
      "archivalSpecs": [],
      "replicationSpecs": [
        {
          "locationId": "$repl_location_id",
          "retentionLimit": 0
        }
      ],
      "numDbs": 0,
      "numFilesets": 7,
      "numLinuxHosts": 3,
      "numWindowsHosts": 2,
      "numVms": 1,
      "isDefault": false,
      "uiColor": "#cc8366"
    }
    ```
    ## Working with SLA Domains
    To work with an SLA Domain, obtain the `id` of that SLA Domain. As described in [Retrieving SLA Domains](#section/SLA-Domains/Retrieving-SLA-Domains), start by sending a GET request to [`/sla_domain`](#operation/querySlaDomain).
    The Rubrik REST API server responds with a `ListResponse` object that contains all of the SLA Domains on the specfied Rubrik cluster. From that list object, find the data array element that has the `name` value of the selected SLA Domain. In the same array element as the `name` value, note the value of the `id` string.
    ## Creating SLA Domains
    To create an SLA domain send a POST request to [`/sla_domain`](#operation/createSlaDomain). Include the attributes for the SLA Domain in the request body.
    The following table describes the required and optional attributes to include in the request body when creating an SLA Domain.
    | Attribute | Req'd | JSON Type | Description |
    | ------ | --- | ----- | ----------- |
    | `name` | Yes | String | Name of the SLA Domain.  |
    | `frequencies` | Yes | Array | Each member defines a policy by specifying: `timeUnit`, `frequency`, and `retention`. Requires at least one member in the array.  |
    | `allowedBackupWindows` | Yes | Array | Each member defines a period when backups are allowed by specifying: `startTimeAttributes` and `durationInHours`. Several backup windows can be specified by adding an array member for each one. Create an SLA Domain without a backup window by specifying a null array value: `[]`.  |
    | `firstFullAllowedBackupWindows` | Yes | Array | Each member defines a period when first full backups are allowed by specifying: `startTimeAttributes` and `durationInHours`. Several first full backup windows can be specified by adding an array member for each one. Create an SLA Domain without a first full backup window by specifying a null array value: `[]`.  |
    | `localRetentionLimit` | No | String | Specify an integer value to set the number of days to retain a local copy of a snapshot. When an archival location is specified, specify `0` to enable Instant Archiving. |
    | `archivalSpecs` | No | Array | Defines the archival location for the SLA Domain by specifying: `locationId` and `archivalThreshold`. Currently limited to one array member. |
    | `replicationSpecs` | No | Array | Defines the replication location for the SLA Domain by specifying: `locationId` and `retentionLimit`. Currently limited to one array member. |
    **Example:** Creating an SLA Domain for daily backups
    Create an SLA Domain that takes a backup once a day and retains the backup for seven days. Do not set a backup window or a first full backup window. Do not include archival or replication.
    ```bash
    curl -X POST \
      -d '{
      "name": "Daily SLA",
      "frequencies": [
        {
          "timeUnit": "Day",
          "frequency": 1,
          "retention": 7
        }
      ],
      "allowedBackupWindows": [],
      "firstFullAllowedBackupWindows": [] }' \
      "https://$cluster_address/api/v1/sla_domain"
    ```
    The response confirms the attributes of the SLA Domain and provides the `id` of the new SLA Domain.
    ```bash
    {
      "id": "$sla_id",
      "name": "Daily SLA",
      "frequencies": [
        {
          "timeUnit": "Day",
          "frequency": 1,
          "retention": 7
        }
      ],
      "allowedBackupWindows": [],
      "firstFullAllowedBackupWindows": []
    }
    ```
    ## Modifying SLA Domains
    To modify the attributes of an SLA domain send a PUT request to [`/sla_domain/{id}`](#operation/updateSlaDomain). Include in the request body the new attributes.
    **Example:** Modifying the daily backup SLA Domain
    Change the SLA Domain that was created in [Creating SLA Domains](#section/SLA-Domains/Creating-SLA-Domains) to increase the retention to 14 days.
    ```bash
    curl -X PUT \
      -d '{
      "name": "Daily SLA",
      "frequencies": [
        {
          "timeUnit": "Day",
          "frequency": 1,
          "retention": 14
        }
      ],
      "allowedBackupWindows": [],
      "firstFullAllowedBackupWindows": [] }' \
      "https://$cluster_address/api/v1/sla_domain/$sla_id"
    ```
    The response confirms the new attribute.
    ```bash
    {
      "id": "$sla_id",
      "name": "Daily SLA",
      "frequencies": [
        {
          "timeUnit": "Day",
          "frequency": 1,
          "retention": 14
        }
      ],
      "allowedBackupWindows": [],
      "firstFullAllowedBackupWindows": []
    }
    ```
    ## Patching SLA Domains
    To patch the attributes of an SLA domain, send a PATCH request to
    [`/sla_domain/{id}`](#operation/patchSlaDomain). Include in the request body
    only the attributes that needs to be patched.
    **Example:** Patching the daily backup SLA Domain
    Patch the SLA Domain that was created in [Creating SLA Domains]
    (#section/SLA-Domains/Creating-SLA-Domains) to change the archival
    specifications.
    ```bash
    curl -X PATCH \
      -d '{
      "archivalSpecs": [
        {
            "locationId": "some-valid-archived-location-id",
            "archivalThreshold": 14
        }
      ]}' \
      "https://$cluster_address/api/v1/sla_domain/$sla_id"
    ```
    The response confirms the new attribute and also includes the other
    attributes that were not changed.
    ```bash
    {
      "id": "$sla_id",
      "name": "Daily SLA",
      "frequencies": [
        {
          "timeUnit": "Day",
          "frequency": 1,
          "retention": 7
        }
      ],
      "archivalSpecs": [
        {
          "locationId": "some-valid-archived-location-id",
          "archivalThreshold": 14
        }
      ],
      "allowedBackupWindows": [],
      "firstFullAllowedBackupWindows": []
    }
    ```
    ## Deleting SLA Domains
    To delete an SLA domain send a DELETE request to [`/sla_domain/{id}`](#operation/deleteSlaDomain).
    **Example:** Deleting an SLA Domain
    Delete an SLA Domain with the `id` of `$sla_id`.
    ```bash
    curl -X DELETE "https://$cluster_address/api/v1/sla_domain/$sla_id"
    ```
    The Rubrik REST API server responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.
    ## Inherited protection
    The Rubrik REST API uses the reserved value `INHERIT` with the `configuredSlaDomainId` string to identify a snappable that derives its protection policy from a parent object. Examples of this:
    * VMware virtual machine inherits from vCenter Server
    * SQL Server database inherits from SQL Server instance
    Every snappable that can be protected through an SLA Domain is represented by an object that has a `configuredSlaDomainId` attribute and an `effectiveSlaDomainId` attribute. The `configuredSlaDomainId` attribute contains either the value of a direct SLA Domain assignment or the reserved value `INHERIT`.
    The `effectiveSlaDomainId` attribute contains the value of the SLA Domain setting that the Rubrik cluster actually applies to the snappable. When the value of the `configuredSlaDomainId` attribute is `INHERIT`, the value of the `effectiveSlaDomainId` attribute is derived from a parent object of the snappable. In all other cases, the value of the `effectiveSlaDomainId` attribute is the same as the value of the `configuredSlaDomainId` attribute.
    ## SLA Domain assignments
    To assign a snappable to an SLA Domain, use the endpoint that is provided for that type of snappable.
    * VMware virtual machines
    Send a PATCH request to  [`/vmware/vm/{id}`](#operation/updateVm). [VMware virtual machines](#section/VMware-virtual-machines) provides more information about this.
    * Linux or Windows filesets
    Send a PATCH request to  [`/fileset/{id}`](#operation/updateFileset). [Filesets](#section/Filesets) provides more information about this.
    * SQL Server databases
    Send a PATCH request to  [`/mssql/db/{id}`](#operation/updateMssqlDb). [SQL Server databases](#section/SQL-Server-databases) provides more information about this.
    # Virtual machines
    The Rubrik cluster protects virtual machines running in a VMware vSphere environment. The Rubrik cluster uses the *VMware vSphere Storage APIs – Data Protection* (VADP) to interact with objects in the vSphere environment. In most cases, the Rubrik cluster works through the vCenter Servers of the environment. For some tasks, the Rubrik cluster can work directly with a VMware ESXi hypervisor.
    ## vCenter servers
    A Rubrik cluster normally protects and manages virtual machines through the vCenter Server that administers those virtual machines. After a vCenter server is added to a Rubrik cluster, the Rubrik cluster automatically discovers the virtual machines that are administered by that vCenter server.
    ### Retrieving vCenter Servers
    Request a list of the vCenter servers that are registered with a Rubrik cluster by sending a GET request to  [`/vmware/vcenter`](#operation/queryVcenter).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/vmware/vcenter"
    ```
    The Rubrik REST API server responds with the first page of a `ListResponse` object.
    ```bash
    {
      "hasMore": false,
      "data": [
        {
          "id": "$vcenter_id0",
          "hostname": "$vcenter_address0",
          "username": "$vcenter_admin0",
          "configuredSlaDomainId": "INHERIT",
          "primaryClusterId": "$cluster_id",
          "caCerts": "$ca_certs0"
        },
        {
          "id": "$vcenter_id1",
          "hostname": "$vcenter_address1",
          "username": "$vcenter_admin1",
          "configuredSlaDomainId": "INHERIT",
          "primaryClusterId": "$cluster_id",
          "caCerts": "$ca_certs1"
        }
      ],
      "total": 2
    }
    ```
    Depending on the number of registered vCenter Servers, all of the entries on the list may not be included on the first page. [Working with lists](#section/Overview/Working-with-lists) describes how to work with a ListResponse object to obtain additional pages of the list.
    ### Adding a vCenter server
    To add a vCenter server, send a POST request to [`/vmware/vcenter`](#operation/createVcenter).
    Include in the body of the request the address of the vCenter server and credentials for a user account (`username`) that has the required permissions. The Rubrik User Guide provides details about creating an account with the required permissions.
    ```bash
    curl -X POST \
      -d '{
        "hostname": "$vcenter_address",
        "username": "$vcenter_admin",
        "password": "$vcenter_password" }' \
      "https://$cluster_address/api/v1/vmware/vcenter"
    ```
    The Rubrik REST API server initiates the asynchronous request task and responds with a task object.
    ```bash
    {
      "id": "$request_id",
      "status": "RUNNING",
      "error": "None",
      "progress": "$request_progress"
      "links": [
        {
          href: "https://$cluster_address/api/v1/vmware/vcenter/request/$request_id",
          rel: "self"
        }
      ]
    }
    ```
    Using the information provided in the task object, send a GET request to the [`/vmware/vcenter/request/{id}`](#operation/getVcenterAsyncRequestStatus) endpoint to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the task finished successfully.
    ### Retrieve vCenter Server details
    Get the details for a vCenter Server that is registered with a Rubrik cluster by sending a GET request to [`/vmware/vcenter/{id}`](#operation/getVcenter).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/vmware/vcenter/{id}"
    ```
    The Rubrik REST API server responds with the details of the specified vCenter Server object.
    ```bash
    {
      "id": "$id",
      "hostname": "$vcenter_address0",
      "username": "$vcenter_admin0",
      "configuredSlaDomainId": "INHERIT",
      "primaryClusterId": "$cluster_id"
    }
    ```
    ### Modifying a vCenter Server entry
    To change the information that a Rubrik cluster stores for a vCenter Server, send a PUT request to [`/vmware/vcenter/{id}`](#operation/updateVcenter). All of the members of the `VcenterConfig` object must be in the PUT request. Using the new values, include in the body of the PUT request each member (`{string : value}`) of the `VcenterConfig` object:
    * `"hostname": "$vcenter_address"`
    * `"username": "$vcenter_admin"`
    * `"password": "$vcenter_password"`
    To change the configured SLA that is configured for a vCenter Server or to change CA certificates for the vCenter, send a PATCH request to[`/vmware/vcenter/{id}`](#operation/patchVcenter).
    ```bash
    curl -X PUT \
      -d '{
        "hostname": "$vcenter_address",
        "username": "$vcenter_admin",
        "password": "$vcenter_password" }' \
      "https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id"
    ```
    The Rubrik REST API server sends a response, with the updated details of the vCenter Server entry in the response body.
    ```bash
    {
      "id": "$vcenter_id",
      "hostname": "$vcenter_address",
      "username": "$vcenter_admin",
      "configuredSlaDomainId": "INHERIT",
      "primaryClusterId": "$cluster_id",
      "caCerts": "$ca_certs"
    }
    ```
    ### Removing a vCenter Server entry
    To remove a vCenter Server entry from a Rubrik cluster, first unmount any Live Mount and Instant Recovery virtual machines for the vCenter Server. Then send a DELETE request to [`/vmware/vcenter/{id}`](#operation/deleteVcenter).
    ```bash
    curl -X DELETE \
      "https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id"
    ```
    The Rubrik REST API server initiates the asynchronous delete task and responds with a task object.
    ```bash
    {
        "id": "$request_id",
        "status": "RUNNING",
        "error": "None",
        "progress": 0,
        "startTime": "$start_timestamp",
        "endTime": "$end_timestamp",
        "links": [
          {
            "href": "https://$cluster_address/api/v1/vmware/vcenter/request/$request_id",
            "rel": "self"
          }
        ]
      }
    ```
    Using the information provided in the task object, send a GET request to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the removal of the vCenter Server object finished successfully.
    ### Metadata refresh
    The Rubrik cluster regularly refreshes the metadata of the registered vCenter Servers. As part of a refresh operation, the Rubrik cluster discovers any changes or additions to the virtual machines that are administered by the vCenter Servers. Instead of waiting for a regular refresh, a metadata refresh can be manually initiated by sending a POST request to [`/vmware/vm/refresh`](#operation/createRefresh), using the Rubrik cluster ID (`$cluster_address`) and the vCenter Server ID (`$vcenter_id`).
    ```bash
    curl -X POST \
      "https://$cluster_address/api/v1/vmware/vcenter/$vcenter_id/refresh"
    ```
    The Rubrik REST API server initiates the asynchronous request task and responds with a task object.
    ```bash
    {
      "id": "$request_id",
      "status": "RUNNING",
      "error": "None",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/vmware/vcenter/request/$request_id",
          "rel": "self"
        }
      ]
    }
    ```
    Using the information provided in the task object, send a GET request to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the metadata refresh completed successfully.
    ## ESXi hypervisors
    Retrieve a list of all available ESXi hypervisors in the vSphere environment by sending a GET request to [`/vmware/host`](#operation/queryVmwareHost).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/vmware/host?primary_cluster_id=$cluster_id"
    ```
    The value of `primary_cluster_id` is the `id` of a Rubrik cluster. Use `local` to retrieve a list for the Rubrik cluster that is hosting the current session.
    The Rubrik REST API server responds with the first page of a `ListResponse` object.
    **Note:** To shorten the example, the response uses ellipsis to replace some members.
    ```bash
    {
      "hasMore": false,
      "data": [
        {
          "id": "$esxi_id",
          "name": "$esxi_name",
          "datacenterId": "$datacenter_id",
          "computeClusterId": "$compute_cluster_id",
          "datastores": [
          ...
          ],
          "configuredSlaDomainId": "INHERIT",
          "primaryClusterId": "$cluster_id"
        }
        ],
      "total": 1
    }
    ```
    Retrieve more details for an ESXi hypervisor by sending a GET request to [`/vmware/host/{id}`](#operation/getVmwareHost)
    ```bash
    curl -X POST \
      "https://$cluster_address/api/v1/vmware/host/$esxi_id"
    ```
    The Rubrik REST API server responds with the details for the specified ESXi hypervisor.
    **Note:** To shorten the example, the response uses ellipsis to replace some members.
    ```bash
    {
      "id": "$esxi_id",
      "moid": "$moid",
      "name": "$esxi_name",
      "computeClusterId": "$compute_cluster_id",
      "datacenter": {
        "id": "$datacenter_id",
        "name": "$datacenter_name",
        "vcenterId": "$vcenter_id",
        "configuredSlaDomainId": "INHERIT",
        "primaryClusterId": "$cluster_id"
      },
      "datastores": [
        ...
      ],
      "virtualMachines": [
        ...
      ],
      "configuredSlaDomainId": "INHERIT",
      "primaryClusterId": "$cluster_id"
    }
    ```
    Additionally, To change the SLA Domain that is configured for an ESXi hypervisor, send a PATCH request on [`/vmware/host`](#operation/updateVmwareHost)
    ```bash
    curl -X POST \
      "https://$cluster_address/api/v1/vmware/host/$snapshot_id"
    ```
    ## Virtual machine protection
    After a vCenter Server is registered, the Rubrik cluster acquires metadata for the virtual machines that are administered through that vCenter Server. Using the metadata, assign Rubrik cluster protection to the virtual machines.
    The typical protection workflow involves the following tasks:
    1. Find the virtual machine resource object.
    2. (Optional) Enable scripts on the virtual machine.
    3. (Optional) Exclude specified vmdk files for the virtual machine.
    4. Assign the virtual machine to an SLA Domain.
    ### Finding virtual machines
    Get a list of the virtual machine objects known to the Rubrik cluster by sending a GET request to [`/vmware/vm`](#operation/queryVm). The Rubrik REST API server returns a response that includes a `ListResponse` object. Use query parameters as part of the GET request, to filter the list and to work with the `ListResponse` object.
    A GET request that is sent to the [`/vmware/vm`](#operation/queryVm) endpoint accepts the query parameters that are described in the following table.
    | Parameter | Description |
    | --------- | ----------- |
    | `effective_sla_domain_id` | SLA Domain applied to the virtual machine, either directly or derived. Use `UNPROTECTED` for virtual machines that do not have a derived or direct SLA Domain. |
    | `primary_cluster_id` | The `id` of the primary Rubrik cluster for the virtual machine. Use `local` for the Rubrik cluster that is hosting the Rubrik REST API session. |
    | `limit` | Maximum number of a elements to include in the `data` array of the response. |
    | `offset` | Index reference point to use when determining the elements to include in the response. |
    | `is_relic` | Relic status of the virtual machine. `true` to specify only relic virtual machines. `false` to exclude relic virtual machines. Do not include the parameter to include both relic and non-relic virtual machines. |
    | `name` | String value to match in any part of the name of a virtual machine.  |
    | `sla_assignment` | SLA Domain assignment status of the virtual machine. Use `derived` for virtual machines that derive protection status from another resource object. Use `direct` for virtual machines that have a directly assigned SLA Domain. Use `unassigned` for virtual machines that do not have a direct or derived SLA Domain. |
    | `sort_by` | Perform an ASCII sort of the elements in the `ListResponse` object data array by a specified object value: `effective_sla_domain_id`, `name`, `folderPath`, or `infraPath`. |
    | sort_order | Sort order for the elements in the ListResponse object data array. Use `asc` for ascending sort or `desc` for descending sort. |
    **Example:** Retrieving a list of virtual machine resource objects
    Retrieve a list of unprotected virtual machine resource objects that have 'test' in their name. Limit the first page of the response to the first object.
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/vmware/vm?effective_sla_domain_id=UNPROTECTED&amp;limit=1&amp;offset=0&amp;name=test"
    ```
    The Rubrik REST API server responds with a `ListResponse` object. The first page has the first object of the 156 objects that matched the query parameters.
    **Note:** To shorten the example, the response uses ellipsis to replace some members.
    ```bash
    {
      "hasMore": true,
      "data": [
        {
          "id": "$vm_id",
          "moid": "$vm_moid",
          "name": "abctest123",
          "vcenterId": "$vcenter_id",
          "hostName": "$esxi_host_name",
          "hostId": "$esxi_host_id",
          "clusterName": "$vcenter_cluster_name",
          "powerStatus": "poweredOn",
          "configuredSlaDomainId": "INHERIT",
          "configuredSlaDomainName": "Inherit",
          "effectiveSlaDomainId": "UNPROTECTED",
          "effectiveSlaDomainName": "Unprotected",
          "slaAssignment": "Unassigned",
          "ipAddress": "$vm_ip",
          "toolsInstalled": true,
          "primaryClusterId": "$cluster_id",
          "isReplicationEnabled": false,
          "folderPath": [
            ...
          ],
          "infraPath": [
            ...
          ],
          "vmwareToolsInstalled": true,
          "isRelic": false,
          "maxNestedVsphereSnapshots": -1,
          "snapshotConsistencyMandate": "UNKNOWN",
          "physicalStorage": 0,
          "guestCredentialAuthorizationStatus": "PENDING"
        }
      ],
      "total": 156
    }
    ```
    ### Retrieving more details for a virtual machine
    To get detailed information for a specified virtual machine object, send a GET request to [`/vmware/vm/{id}`](#operation/getVm).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/vmware/vm/$vm_id"
    ```
    The Rubrik REST API server responds with the details for the virtual machine object.
    **Note:** To shorten the example, the response uses ellipsis to replace some members.
    ```bash
    {
      "id": "$vm_id",
      "moid": "$vm_moid",
      "name": "abctest123",
      "powerStatus": "poweredOn",
      "configuredSlaDomainId": "INHERIT",
      "effectiveSlaDomain": {
        ...
      },
      "slaAssignment": "Unassigned",
      "blackoutWindowStatus": {
        "isGlobalBlackoutActive": false,
        "isSnappableBlackoutActive": false
      },
      "blackoutWindows": {
        ...
        ],
        "snappableBlackoutWindows": []
      },
      "currentHost": {
        ...
      },
      "virtualDiskIds": [
        ...
      ],
      "snapshots": [],
      "ipAddress": "$vm_ip",
      "toolsInstalled": true,
      "snapshotCount": 0,
      "snapshotConsistencyMandate": "",
      "maxNestedVsphereSnapshots": -1,
      "primaryClusterId": "$cluster_id",
      "isReplicationEnabled": false,
      "isRelic": false,
      "physicalStorage": 0,
      "guestOsName": "$guest_os",
      "guestCredentialAuthorizationStatus": "PENDING",
      "isArrayIntegrationPossible": false,
      "isArrayIntegrationEnabled": false
    }
    ```
    ### Enabling scripts
    A virtual machine object can be configured to start scripts on the guest operating system. A script can be started before the backup (`preBackupScript`), after the snapshot completes (`postSnapScript`), and after the backup task completes (`postBackupScript`). The *Rubrik User Guide* provides information about script requirements.
    To configure a virtual machine object to start scripts, send a PATCH request to [`/vmware/vm/{id}`](#operation/updateVm). Since this is a PATCH request, only the elements of the virtual machine object that are modified or added should be included in the request body. All three script members are shown in the request body in this model, but all are optional.
    ```bash
    curl -X PATCH \
     -d '{
          "preBackupScript": {
            "scriptPath": "$pre_script_path",
            "timeoutMs": 10000,
            "failureHandling": "abort"
          },
          "postSnapScript": {
            "scriptPath": "$postsnap_script_path",
            "timeoutMs": 10000,
            "failureHandling": "abort"
          },
          "postBackupScript": {
            "scriptPath": "$postbackup_script_path",
            "timeoutMs": 10000,
            "failureHandling": "abort"
          }
        }' \
      "https://$cluster_address/api/v1/vmware/vm/$vm_id"
    ```
    The Rubrik REST API server sends an HTTP 200 response that includes the modified or added members in the response body.
    #### Manually starting a virtual machine script
    For testing or to run a script before running a backup, manually trigger the script by sending a POST request to [`/vmware/vm/{id}/guest_script/run`](#operation/runGuestOsScript). To manually start a script, the script must first be a part of the configuration of the virtual machine object. Use the value of the `phase` member to identify the script, as follows:
    * Use `PreBackup` for the script identified by the `preBackupScript` member.
    * Use `PostSnap` for the script identified by the `postSnapScript` member.
    * Use `PostBackup` for the script identified by the `postBackupScript` member.
    ```bash
    curl -X POST \
      -d '{
        "phase": "PreBackup" }' \
      "https://$cluster_address/api/v1/vmware/vm/$vm_id/guest_script/run"
    ```
    The Rubrik REST API server responds with an HTTP 204 response when the script finishes with a 0 exit code.
    ### Excluding a VMDK file
    The Rubrik cluster can be configured to ignore some of the VMDK files of a virtual machine while protecting the other VMDK files of that virtual machine. To exclude a VMDK file, send a GET request to [`/vmware/vm/virtual_disk/{id}`](#operation/getVirtualDisk) using the `$disk_id` of the VMDK file.
    To get the `$disk_id` values, send a GET request to [`/vmware/vm/{id}`](#operation/getVm). The response body has the `disk_id` values for the virtual machine in the `virtualDiskIds` array.
    After identifying the `$disk_id` for a VMDK file, obtain the current state of the VMDK file.
    ```bash
    curl -X GET "https://$cluster_address/api/v1/vmware/vm/virtual_disk/$disk_id"
    ```
    The Rubrik REST API server responds with the value of `excludeFromSnapshots`.
    ```bash
    {
      "id": "$disk_id",
      "excludeFromSnapshots": false
    }
    ```
    When the value is `false` the Rubrik cluster is not configured to exclude the VMDK file. Change this value to `true` to instruct the Rubrik cluster to exclude the VMDK file from all subsequent snapshots of the virtual machine.
    Send a PATCH request to [`/vmware/vm/virtual_disk/{id}`](#operation/updateVirtualDisk) to change the value of `excludeFromSnapshots` to `true` and exclude the VMDK file.
    ```bash
    curl -X PATCH \
      -d '{
        "excludeFromSnapshots": true }' \
      "https://$cluster_address/api/v1/vmware/vm/virtual_disk/$disk_id"
    ```
    The Rubrik REST API server responds with the updated `excludeFromSnapshots` value for the VMDK file.
    ```bash
    {
      "id": "$disk_id",
      "excludeFromSnapshots": true
    }
    ```
    ### Assigning a virtual machine to an SLA Domain
    To protect a virtual machine through the rules and policies of an SLA Domain send a PATCH request to [`/vmware/vm/{id}`](#operation/updateVm) with the value of `configuredSlaDomainId` set to the `$sla_domain_id`.
    **Note:** [Retrieving SLA Domains](#section/SLA-Domains/Retrieving-SLA-Domains) describes how to retrieve the SLA Domain objects on a Rubrik cluster.
    ```bash
    curl -X PATCH -d \
      '{
        "configuredSlaDomainId": "$sla_domain_id"
      }' \
      "https://$cluster_address/api/v1/vmware/vm/$vm_id"
    ```
    The Rubrik REST API server responds with confirmation of the assignment.
    ```bash
    {
      "id": "$vm_id",
      "configuredSlaDomainId": "$sla_domain_id"
    }
    ```
    ## Snapshot management
    Managing snapshots includes the following possible actions:
    * Retrieving snapshot information
    * Retrieving snapshot details
    * Retrieving missed snapshot information
    * Creating on-demand snapshots
    * Expiring individual snapshots
    * Expiring all snapshots for a virtual machine
    ### Retrieving snapshot information
    To retrieve a list of the snapshots for a virtual machine, send a GET request to [`/vmware/vm/{id}/snapshot`](#operation/querySnapshot).
    ```bash
    curl -X GET "https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot"
    ```
    The Rubrik REST API server responds with a `ListResponse` object.
    ```bash
    {
      "hasMore": false,
      "data": [
        {
          "date": "$timestamp0",
          "indexState": 0,
          "cloudState": 0,
          "vmName": "$vm_name",
          "replicationLocationIds": [],
          "id": "$snapshot_id0",
          "consistencyLevel": "$consistency_level0",
          "archivalLocationIds": [],
          "isOnDemandSnapshot": false
        },
        {
          "date": "$timestamp1",
          "indexState": 0,
          "cloudState": 0,
          "vmName": "$vm_name",
          "replicationLocationIds": [],
          "id": "$snapshot_id1",
          "consistencyLevel": "$consistency_level1",
          "archivalLocationIds": [],
          "isOnDemandSnapshot": true
        }
     ],
     "total": 2
    }
    ```
    Each member of the data array includes the `id` of a snapshot. Use this value (`$snapshot_id`) to perform tasks with the snapshot, such as:
    * Browsing for data in the snapshot
    * Downloading data from the snapshot
    * Restoring data from the snapshot
    * Exporting data from the snapshot
    * Mounting a virtual machine from the snapshot
    ### Retrieving snapshot details
    To retrieve details for a specified snapshot send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id"
    ```
    The Rubrik REST API server responds with the details of the specified snapshot.
    **Note:** To shorten the example, the response uses ellipsis to replace some members.
    ```bash
    {
      "date": "$timestamp",
      "indexState": 0,
      "virtualMachine": {
       ...
      },
      "vmName": "$vm_name",
      "isCorrupt": false,
      "replicationLocationIds": [],
      "archivalLocationIds": [],
      "snapshotDiskIds": [
        "$vmdk_id"
      ],
      "isOnDemandSnapshot": false,
      "cloudState": 0,
      "id": "$snapshot_id",
      "consistencyLevel": "1",
      "config": "[]"
    }
    ```
    ### Retrieving missed snapshot information
    The Rubrik cluster stores information for missed snapshots. *Missed snapshots* are snapshot tasks that are not completed as required by the rules and policies of an SLA Domain.  Retrieve missed snapshot information for a virtual machine by sending  a GET request to [`/vmware/vm/{id}/missed_snapshot`](#operation/missedSnapshots).
    ```bash
    curl -X GET "https://$cluster_address/api/v1/vmware/vm/$vm_id/missed_snapshot"
    ```
    The Rubrik REST API server responds with a `ListResponse` object.
    ```bash
    {
      "hasMore": false,
      "data": [
        {
          "archivalLocationType": [
            "missed"
          ],
          "missedSnapshotTime": "$timestamp0"
        },
        {
          "archivalLocationType": [
            "missed"
          ],
          "missedSnapshotTime": "$timestamp1"
        }
      ],
      "total": 2
    }
    ```
    ### Creating on-demand snapshots
    On-demand snapshots can be created for both protected and unprotected virtual machines. To create an on-demand snapshot of a virtual machine send a POST request to [`/vmware/vm/{id}/snapshot`](#operation/createOnDemandBackup).
    ```bash
    curl -X POST \
      "https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot"
    ```
    The Rubrik REST API server initiates the asynchronous snapshot task and responds with a task object.
    ```bash
    {
      "id": "$request_id",
      "status": "ACQUIRING",
      "progress": 0,
      "startTime": "$timestamp",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/vmware/vm/request/$request_id",
          "rel": "self"
        }
      ]
    }
    ```
    Using the information provided in the task object, send a GET request to poll the task status. When the value of `status` in the task object is `SUCCEEDED`, the on-demand snapshot finished successfully.
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/vmware/vm/request/$request_id"
    ```
    The Rubrik REST API server sends a task object with `status="SUCCEEDED"`.  The task object for a successful snapshot includes the URI for the snapshot: `https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id`.
    ```bash
    {
      "id":"$request_id",
      "status":"SUCCEEDED",
      "startTime":"$timestamp0",
      "endTime":"$timestamp1",
      "links":[
        {
          "href":"https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id",
          "rel":"result"
        },
       {
          "href":"https://$cluster_address/api/v1/vmware/vm/request/$request_id",
          "rel":"self"
       }
      ]
    }
    ```
    ### Expiring individual snapshots
    On-demand snapshots and snapshots for unprotected virtual machines can be expired by using the snapshot `id`. To expire an individual snapshot, send a DELETE request to [`/vmware/vm/snapshot/{id}`](#operation/deleteVmwareSnapshot). Include the query parameter `location` to specify whether to expire all copies of the snapshot, or only the local copy. Use `location=local` to expire only the copy of the snapshot on the specified Rubrik cluster. Use `location=all` to expire all copies of the snapshot, including replicas and archival copies.
    ```bash
    curl -X DELETE \
      "https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id?location=$snapshot_location"
    ```
    The Rubrik REST API server expires the specified snapshot and responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.
    The Rubrik REST API server responds with HTTP response code 422 'Unprocessable Entity', when the specified snapshot is not one of the following:
    * On-demand snapshot
    * Snapshot for an unprotected virtual machine
    ### Expiring all snapshots for a virtual machine
    All snapshots for an unprotected virtual machine can be expired by using the virtual machine `id`. To expire all snapshots for an unprotected virtual machine, send a DELETE request to [`/vmware/vm/{id}/snapshot`](#operation/deleteVmwareSnapshots). The Rubrik cluster expires all snapshots, replicas, and archival snapshots for the specified virtual machine.
    ```bash
    curl -X DELETE \
      "https://$cluster_address/api/v1/vmware/vm/$vm_id/snapshot"
    ```
    The Rubrik REST API server expires all snapshots for the specified virtual machine in all locations and responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.
    The Rubrik REST API server responds with HTTP response code 422 'Unprocessable Entity', when the specified virtual machine is protected through an SLA Domain assignment.
    ## Data recovery
    To recover a file or folder from a snapshot, retrieve the `id` of the file or folder using either search or browse. Then use the `id` with one of the recovery methods:
    * Download the file or folder
    * Restore the file or folder to the source location
    * Export the file or folder to another host
    ### Searching for data in snapshots
    Search for files and folders across all indexed snapshots of a virtual machine by using the virtual machine `id`. Send a GET request to [`/vmware/vm/{id}/search`](#operation/searchVm) with the `path` query parameter. Use a path segment string or a name segment string for the value of `path`.
    **IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot) as described in the 'Retrieving snapshot information' section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of `indexState`. A value of `1` means the snapshot has been indexed. A value of `0` means the snapshot has not been indexed.
    The Rubrik REST API server uses the rules described in the following table when matching the value of `path` with folders and files in the indexed snapshots.
    | Type | Rule | Description |
    | ---- | ---- | ----------- |
    | Path delimiter | Forward slashes and backslashes are equally recognized as path delimiters. | In the value of path, `/` matches both `/` and `\`, and `\` matches both `/` and `\`. |
    | Path segments | Path segments match all files and folders that begin with the same path segment. | For example, '/abc/x' matches files and folders at '/abc/' or '\abc\\' with a filename or folder name that starts with 'x'. |
    | Name segments | Name segments match all files and folders that begin with the same name segment. | For example, 'xyz' matches files and folders with a filename or folder name that starts with 'xyz', in all path locations. |
    | Characters | Any character that the guest operating system accepts in a file path can be used.  | For example, the greater than symbol `&gt;` and the lesser than symbol `&lt;` are not allowed. |
    | Windows drive | To specify a full path on a Windows guest follow the Windows file system requirement. | For example, to specify the 'temp' folder on the 'D' drive of a Windows virtual machine, use: `D:\temp`. |
    **Example:** Searching for files and folders
    Search for all files and folders in '/usr/local/' with a name that starts with the later 'g'.
    Send a GET request to [`/vmware/vm/{id}/search`](#operation/searchVm) with `path=/usr/local/g`.
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/vmware/vm/$vm_id/search?path=%2Fusr%2Flocal%2Fg"
    ```
    The Rubrik REST API server responds with a `ListResponse` object. The data array has two members, a directory at: `/usr/local/games` and a file at: `/usr/local/gamehints`.
    ```bash
    {
      "hasMore": false,
      "data": [
        {
          "path": "/v1/v1/usr/local/games",
          "filename": "games",
          "fileVersions": [
            {
              "lastModified": "$timestamp0",
              "size": 4096,
              "snapshotId": "$snapshot_id0",
              "fileMode": "directory",
              "source": "cloud"
            }
          ]
        },
        {
        "path": "/usr/local/gamehints",
        "filename": "gamehints",
        "fileVersions": [
          {
            "lastModified": "$timestamp1",
            "size": 14480,
            "snapshotId": "$snapshot_id1",
            "fileMode": "file",
            "source": "cloud"
          },
          {
            "lastModified": "$timestamp2",
            "size": 14480,
            "snapshotId": "$snapshot_id2",
            "fileMode": "file",
            "source": "cloud"
          }
        ]
       }
      ],
      "total": 2
    }
    ```
    ### Browsing for data in snapshots
    Browse for files and folders with an indexed snapshot by using the snapshot `id`. Send a GET request to  [`/vmware/vm/snapshot/{id}/browse`](#operation/browseVmwareSnapshot) with the `path` query parameter.  Use a path segment string for the value of `path`. The response provides a ListResponse object that includes all of the files and folders in the directory that is specified by the value of `path`.
    **IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot) as described in the 'Retrieving snapshot information' section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of `indexState`. A value of `1` means the snapshot has been indexed. A value of `0` means the snapshot has not been indexed.
    The Rubrik REST API server uses the rules described in the following table when matching the value of `path` with the path in the specified snapshot.
    | Type | Rule | Description |
    | ---- | ---- | ----------- |
    | Path delimiter | Forward slashes and backslashes are equally recognized as path delimiters. | In the value of path, `/` matches both `/` and `\`, and `\` matches both `/` and `\`. |
    | Path description | The path description must end in a directory name, without an ending slash. | For example, '/abc/x' returns all files and folders in the directory at '/abc/x', but '/abc/x/' returns an HTTP 422 response. |
    | Characters | Any character that the guest operating system accepts in a file path can be used.  | For example, the greater than symbol `&gt;` and the lesser than symbol `&lt;` are not allowed. |
    | Windows drive | To specify a full path on a Windows guest follow the Windows file system requirement. | For example, to specify the 'temp' folder on the 'D' drive of a Windows virtual machine, use: `D:\temp`. |
    **Example:** Browsing for files and folders
    Retrieve a ListResponse object with all of the files and folders in '/home'.
    Send a GET request to  [`/vmware/vm/snapshot/{id}/browse`](#operation/browseVmwareSnapshot) with `path=/home`.
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/browse?path=%2Fhome&amp;offset=0"
    ```
    The Rubrik REST API server responds with a `ListResponse` object. The data array has two members, the directory: `ubuntu` and the file: `ubuntu.tar`.
    ```bash
    {
      "hasMore": false,
      "data": [
        {
          "filename": "ubuntu",
          "path": "ubuntu",
          "lastModified": "$timestamp0",
          "size": 31892819777,
          "fileMode": "directory",
          "statusMessage": ""
        },
        {
          "filename": "ubuntu.tar",
          "path": "ubuntu.tar",
          "lastModified": "$timestamp1",
          "size": 4746675383,
          "fileMode": "file",
          "statusMessage": ""
        }
      ],
      "total": 2
    }
    ```
    ### Downloading data from a snapshot
    Data can be retrieved from a snapshot by creating a download link for an individual file and folder from the snapshot. To have the Rubrik cluster create a download link, send a POST request to [`/vmware/vm/snapshot/{id}/download`](#operation/createDownloadFileJob). Include in the request body the string/value pair: `"path":"$path"`, where `$path` is the full path to the file or folder. When `$path` refers to a folder, the Rubrik cluster creates a ZIP file of the folder and all that it contains.
    The basic download work flow is:
    1. Send a POST request to start the asynchronous download task.
    2. Send a GET request to poll the task status.
    3. When the task succeeds, use the download link provided in the response body to retrieve the file or folder.
    **IMPORTANT:** The snapshot used in this task must be indexed. Indexing makes the file system structure of the data available to the Rubrik cluster. To determine whether a snapshot has been successfully indexed, send a GET request to [`/vmware/vm/snapshot/{id}`](#operation/getSnapshot) as described in the 'Retrieving snapshot information' section of [Snapshot management](#section/Virtual-machines/Snapshot-management). Look at the value of `indexState`. A value of `1` means the snapshot has been indexed. A value of `0` means the snapshot has not been indexed.
    ```bash
    curl -X POST -d \
    '{
       "path": "$full_source_path"
     }' \
     'https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/download_file'
    ```
    The Rubrik REST API server initiates the asynchronous request task and responds with a task object.
    ```bash
    {
      "id": "$download_task_id",
      "status": "QUEUED",
      "progress": 0,
      "startTime": "$timestamp",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/vmware/vcenter/request/$request_id",
          "rel": "self"
        }
      ]
    }
    ```
    ### Restoring data from a snapshot
    To restore a file or folder to the source virtual machine send a POST request to [`/vmware/vm/snapshot/{id}/restore_file`](#operation/createRestoreFileJob). With the request, include a request body. The following table describes the members of the request body.
    | Name | Description |
    | ---- | ----------- |
    | `path` | Full path of the file or folder. |
    | `domainName` | Authentication domain for the credentials being used to authenticate and authorize the action. |
    | `username` | Username of account to authenticate and authorize the action. |
    | `password` | Password for the account to authenticate and authorize the action. |
    | `restorePath` | Full path location for the restore of the file or folder. The action can create a directory at the end of the specified path, but cannot create directories that are specified within the path. |
    | `shouldSaveCredentials` | Instruct the Rubrik cluster to save the credentials included in the request. Use `true` to save the credentials and `false` to use the credentials only for the current request. |
    ```bash
    curl -X POST -d \
    '{
       "path": "$full_source_path",
       "domainName": "$auth_domain",
       "username": "$username",
       "password": "$password",
       "restorePath": "$full_restore_path",
       "shouldSaveCredentials": true
     }' \
     "https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/restore_file"
    ```
    The Rubrik REST API server initiates the asynchronous request task and responds with a task object.
    ```bash
    {
      "id": "$restore_task_id",
      "status": "QUEUED",
      "progress": 0,
      "startTime": "$timestamp",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/vmware/vcenter/request/$request_id",
          "rel": "self"
        }
      ]
    }
    ```
    ## Snapshot mount operations
    Snapshot mount operations include the following possible actions:
    * Retrieving a snapshot from an archival location
    * Mounting a snapshot by using Instant Recovery
    * Mounting a snapshot by using Live Mount
    * Exporting a snapshot
    * Changing the properties of a mounted virtual machine
    * Removing a virtual machine mount
    ### Retrieving a snapshot from an archival location
    To work with a snapshot that is stored only at an archival location, first download the snapshot to the Rubrik cluster by sending a POST request to [`/vmware/vm/snapshot/{id}/download`](#operation/createDownloadSnapshotFromCloud).
    ```bash
    curl -X POST \
      "https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/download"
    ```
    The Rubrik REST API server initiates the asynchronous request task and responds with a task object.
    ```bash
    {
      "id": "$snap_download_task_id",
      "status": "QUEUED",
      "progress": 0,
      "startTime": "$timestamp",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/vmware/vcenter/request/$request_id",
          "rel": "self"
        }
      ]
    }
    ```
    ### Mounting a snapshot by using Instant Recovery
    Replace a source virtual machine from a snapshot by using the Instant Recovery feature. To use Instant Recovery, send a POST request to [`/vmware/vm/snapshot/{id}/instant_recover`](#operation/createInstantRecovery). This request requires a snapshot `id` and can optionally include the parameters that are described in the following table.
    | Name | Description |
    | ---- | ----------- |
    | `hostId` | The `id` of an ESXi hypervisor. When not specified, the Rubrik cluster uses the original hypervisor. |
    | `vmName` | Assigns a specified name to the virtual machine. |
    | `removeNetworkDevices` | Determines whether the virtual machine has network devices. Use `true` to remove network devices from the virtual machine. Use `false` to keep the existing network devices. |
    ```bash
    curl -X POST -d \
      '{
        "vmName": "$vm_name",
        "hostId": "$esxi_id",
        "removeNetworkDevices": true
       }' \
       "https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/instant_recover"
    ```
    The Rubrik REST API server initiates the asynchronous request task and responds with a task object.
    ```bash
    {
      "id": "$instant_recovery_task_id",
      "status": "QUEUED",
      "progress": 0,
      "startTime": "$timestamp",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/vmware/vcenter/request/$request_id",
          "rel": "self"
        }
      ]
    }
    ```
    ### Mounting a snapshot by using Live Mount
    Mount a new virtual machine from a snapshot by using the Live Mount feature. To use Live Mount, send a POST request to [`/vmware/vm/snapshot/{id}/mount`](#operation/createMountV1). This request requires a snapshot `id` and can optionally include the parameters that are described in the following table.
    | Name | Description |
    | ---- | ----------- |
    | `hostId` | The `id` of an ESXi hypervisor. When not specified, the Rubrik cluster uses the original hypervisor. |
    | `vmName` | Assigns a specified name to the virtual machine. |
    | `dataStoreName` | Assigns a specified name for the data store that the Rubrik cluster creates for the Live Mount. |
    | `disableNetwork` | Determines whether the virtual machine has access to the network. Use `true` to Mount the snapshot with network access disabled. Use `false` to allow the virtual machine to access the network. |
    | `removeNetworkDevices` | Determines whether the virtual machine has network devices. Use `true` to remove network devices from the virtual machine. Use `false` to keep the existing network devices. |
    | `powerOn` | Determines whether the virtual machine is powered on after mounting. Use `true` to power on the virtual machine. Use `false` to leave the virtual machine powered off after mounting. |
    ```bash
    curl -X POST \
      -d '{
         "hostId": "$esxi_id",
         "vmName": "$vm_name",
         "dataStoreName": "$datastore_name",
         "disableNetwork": $network_state,
         "removeNetworkDevices": $network_devices_state,
         "powerOn": $power_state
       }'\
        "https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/mount"
    ```
    The Rubrik REST API server initiates the asynchronous request task and responds with a task object.
    ```bash
    {
      "id": "$live_mount_task_id",
      "status": "QUEUED",
      "progress": 0,
      "startTime": "$timestamp",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/vmware/vcenter/request/$request_id",
          "rel": "self"
        }
      ]
    }
    ```
    ### Retrieving the ID of the mount
    After a mount task successfully completes, the `id` of the mount object can be retrieved by sending a GET request to [`/vmware/vm/request/{id}`](#operation/getAsyncRequestStatus) and using the `$request_id` value from the original request object for the Live Mount.
    ```bash
    curl -X GET "https://$cluster_address/api/v1/vmware/vm/request/$request_id"
    ```
    The Rubrik REST API server responds with a request object that includes the `id` of the mount object.
    ```bash
    {
      "id": "$request_id",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id",
          "rel": "result"
        },
        {
          "href": "https://$cluster_address/api/v1/vmware/vm/request/$request_id",
          "rel": "self"
        }
      ],
      "status": "SUCCEEDED"
    }
    ```
    ### Retrieving active mounts
    To retrieve a list of all of the active mounts for a Rubrik cluster, send a GET request to [`/vmware/vm/snapshot/mount`](#operation/queryMountV1).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/vmware/vm/snapshot/mount"
    ```
    The Rubrik REST API server responds with a ListResponse object.
    ```bash
    {
      "hasMore": false,
      "data": [
        {
          "id": "$mount_id",
          "snapshotDate": "$snapshot_timestamp",
          "vmId": "$source_vm_id",
          "mountedVmId": "$mounted_vm_id",
          "hostId": "$esxi_id",
          "isReady": true
        }
      ],
      "total": 1
    }
    ```
    ### Retrieving the details for a mount
    To retrieve details about a specific mount, send a GET request to [`/vmware/vm/snapshot/mount/{id}`](#operation/getMountV1).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id"
    ```
    The Rubrik REST API server responds with the details.
    ```bash
    {
      "snapshotDate": "$timestamp",
      "vmId": "$source_vm_id",
      "isReady": true,
      "hostId": "$esxi_id",
      "id": "$mount_id",
      "mountedVmId": "$mounted_vm_id"
    }
    ```
    ### Exporting a snapshot
    To export a snapshot send a POST request to [`/vmware/vm/snapshot/{id}/export`](#operation/createExport).  This request requires a snapshot `id` and the parameters that are described in the following table.
    | Name | Description |
    | ---- | ----------- |
    | `datastoreId` | The `id` of a datastore for the specified ESXi hypervisor. |
    | `vmName` | Assigns a specified name to the virtual machine. |
    | `hostId` | The `id` of an ESXi hypervisor. |
    | `disableNetwork` | Determines whether the virtual machine has access to the network. Use `true` to Mount the snapshot with network access disabled. Use `false` to allow the virtual machine to access the network. |
    | `removeNetworkDevices` | Determines whether the virtual machine has network devices. Use `true` to remove network devices from the virtual machine. Use `false` to keep the existing network devices. |
    | `powerOn` | Determines whether the virtual machine is powered on after mounting. Use `true` to power on the virtual machine. Use `false` to leave the virtual machine powered off after mounting. |
    | `unregisterVm` | Determines whether to add the exported virtual machine to the vCenter Server inventory. Use `true` to remove the exported virtual machine from the associated vCenter Server inventory. Use `false` to add the exported virtual machine to the associated vCenter Server inventory. |
    ```bash
    curl -X  -d \
     '{
       "datastoreId": "string",
       "vmName": "string",
       "hostId": "string",
       "disableNetwork": true,
       "removeNetworkDevices": true,
       "powerOn": true,
       "unregisterVm": true
     }' \
     "https://$cluster_address/api/v1/vmware/vm/snapshot/$snapshot_id/export"
    ```
    The Rubrik REST API server initiates the asynchronous request task and responds with a task object.
    ```bash
    {
      "id": "$export_task_id",
      "status": "QUEUED",
      "progress": 0,
      "startTime": "$timestamp",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/vmware/vcenter/request/$request_id",
          "rel": "self"
        }
      ]
    }
    ```
    ### Changing power status of a mounted virtual machine
    To change the power status of a mounted virtual machine send a PATCH request to [`/vmware/vm/snapshot/mount/{id}`](#operation/updateMount). Include in the request body, the member `"powerStatus": $power_state`. For `$power_state`, use `true` to power on the virtual machine, or use `false` to power off the virtual machine.
    ```bash
    curl -X PATCH \
      -d '{
        "powerStatus": $power_state }' \
      "https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id"
    ```
    The Rubrik REST API server responds with the mount details.
    ```bash
    {
      "powerStatus": "$power_state",
      "id": "$mount_id",
      "snapshotDate": "$timestamp",
      "vmId": "$vm_id",
      "mountedVmId": "$mounted_vm_id",
      "hostId": "$esxi_id",
      "isReady": true,
      "mountRequestId": "$mount_request_id",
      "unmountRequestId": "$unmount_request_id"
    }
    ```
    ### Removing a virtual machine mount
    To remove a Live Mount send a DELETE request to [`/vmware/vm/snapshot/mount/{id}`](#operation/createUnmount). To remove a mount object after live migration of the virtual machine include the query parameter `force=true`.
    ```bash
    curl -X DELETE \
      "https://$cluster_address/api/v1/vmware/vm/snapshot/mount/$mount_id"
    ```
    The Rubrik REST API server initiates the asynchronous request task and responds with a task object.
    ```bash
    {
      "id": "$delete_mount_task_id",
      "status": "QUEUED",
      "progress": 0,
      "startTime": "$timestamp",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/vmware/vcenter/request/$request_id",
          "rel": "self"
        }
      ]
    }
    ```
    # Hosts
    Rubrik clusters can protect file system data and application data through direct interaction with a host operating system. This method of protection does not require a virtual environment API. Instead, the Rubrik cluster works with the Rubrik Backup Service software that is running on supported Linux hosts and Windows hosts.
    In some situations, the Rubrik cluster can directly interact with hosts without the Rubrik Backup Service, for example when providing protection of data on a network share.
    ## Rubrik Backup Service
    The Rubrik Backup Service software must be installed on a host to enable file system level protection and direct protection of supported applications. The Rubrik Backup Service software is signed by a specific Rubrik cluster and can only be used with that Rubrik cluster.
    The following URLs provide access to the Rubrik Backup Service software on a Rubrik cluster:
    * Linux: https://$cluster_address/connector/rubrik-agent.x86_64.rpm
    * Windows: https://$cluster_address/connector/RubrikBackupService.zip
    **IMPORTANT:** The Rubrik User Guide describes how to install the Rubrik Backup Service software, and lists the permissions and settings that are required to allow the Rubrik Backup Service to provide support for specific operating systems, applications, and clusters.
    ## Registering a host
    After installing the Rubrik Backup Service on a host, register the host with the Rubrik cluster. Registering initiates secure communication between the Rubrik cluster and the Rubrik Backup Service on the host. After a host is registered, the Rubrik Backup Service on the host sends detailed information about the host to the Rubrik cluster.
    The Rubrik Backup Service scans a registered host for protectable objects, such as: applications, databases, and Windows clusters. The Rubrik Backup Service sends the results of the scan to the Rubrik cluster.
    To register a host, send a POST request to [`/host`](#operation/registerHost) and include `hostname: $hostname`. The `$hostname` value must be the IPv4 address of the host or the resolvable hostname of the host.
    ```bash
    curl -X POST \
      -d '{
        "hostname": "$hostname" }' \
      "https://$cluster_address/api/v1/host"
    ```
    The Rubrik REST API server responds with the details for the host, including the connection status.
    ```bash
    {
      "id": "$host_id",
      "hostname": "$hostname",
      "primaryClusterId": "$cluster_id",
      "agentId": "$agent_id",
      "operatingSystem": "$os_version",
      "operatingSystemType": "$os_type",
      "status": "Connected",
      "compressionEnabled": false
    }
    ```
    ## Retrieving host information
    To retrieve a current list of the hosts that are registered with a Rubrik cluster, send a GET request to [`/host`](#operation/queryHost).
    ```bash
    curl -X GET "https://$cluster_address/api/v1/host"
    ```
    The Rubrik REST API server responds with a ListResponse object that contains the first page of the current list.
    ```bash
    {
      "hasMore": false,
      "data": [
        {
          "id": "$host_id0",
          "hostname": "$hostname0",
          "primaryClusterId": "$cluster_id",
          "operatingSystem": "$os_version0",
          "operatingSystemType": "$os_type0",
          "status": "Connected"
        },
        {
          "id": "$host_id1",
          "hostname": "$hostname1",
          "primaryClusterId": "$cluster_id",
          "operatingSystem": "$os_version1",
          "operatingSystemType": "$os_type1",
          "status": "Connected"
        }
      ],
      "total": 2
    }
    ```
    Depending on the number of registered hosts, the complete list of registered hosts may not be included on the first page. [Working with lists](#section/Overview/Working-with-lists) describes how to work with a ListResponse object to obtain additional pages of the list.
    To retrieve the details for a specified host, send a GET request to [`/host/{id}`](#operation/getHost).
    Adding a host will cause Rubrik to communicate with the remote Rubrik agent and get detailed information about the host.
    ```bash
    curl -X GET "https://$cluster_address/api/v1/host/$host_id0"
    ```
    The Rubrik REST API server responds with the details of the specified host.
    ```bash
      {
        "id": "$host_id0",
        "hostname": "$hostname0",
        "primaryClusterId": "$cluster_id",
        "agentId": "$agent_id",
        "operatingSystem": "$os_version0",
        "operatingSystemType": "$os_type0",
        "status": "Connected",
        "compressionEnabled": false
      }
    ```
    ## Adding a host without the Rubrik Backup Service
    A host without the Rubrik Backup Service can be added by setting the `hasAgent` flag to `false`. This can be used to register a host that will be accessed through network shares.
    ```bash
    curl -X POST \
      -d '{ \
        "hostname": "$hostname",
        "hasAgent": "false" }' \
      "https://$cluster_address/api/v1/host"
    ```
    ## Modifying a registered host
    To change the FQDN or IPv4 address that the Rubrik cluster uses to connect with a registered host, send a PATCH request to [`/host`](#operation/updateHost). Use the value of `hostname` to specify the new FQDN or IPv4 address of the host. Optionally, also use this PATCH request to specify whether to compress the data that is transmitted to and from the host. Set the value of `compressionEnabled` to `true` to enable compression or set the value to `false` to turn compression off.
    ```bash
    curl -X POST \
      -d '{
        "hostname": "$hostname",
        "compressionEnabled": true }' \
      "https://$cluster_address/api/v1/host/$host_id"
    ```
    The Rubrik REST API server responds with a confirmation of the new details of the registered host.
    ```bash
     {
      "id": "$host_id",
      "hostname": "$hostname",
      "primaryClusterId": "$cluster_id",
      "agentId": "$agent_id",
      "operatingSystem": "$os_version",
      "operatingSystemType": "$os_type",
      "status": "Connected",
      "compressionEnabled": true
     }
    ```
    ## Removing a host
    Remove a host from the Rubrik cluster when the host no longer requires protection. The Rubrik cluster moves all of the unexpired backups for the host filesets of the host to Unmanaged Objects.
    To remove a host send a DELETE request to [`/host/{id}`](#operation/deleteHost).
    ```bash
    curl -X DELETE \
      "https://$cluster_address/api/v1/host/$host_id"
    ```
    The Rubrik REST API server responds with HTTP response code 204. This indicates the request succeeded and the response body is empty.
    ## Windows Server Failover Clustering nodes
    To begin working with Windows Server Failover Clustering (WSFC) clusters, register each WSFC node with the Rubrik cluster as described in [`Registering a host`](#section/Hosts/Registering-a-host). The scan performed by the Rubrik Backup Service on each WSFC node detects the WSFC cluster and provides information about the WSFC cluster to the Rubrik cluster.
    To view WSFC cluster information, send a GET request to [`/windows_cluster`](#operation/queryWindowsCluster).
    **Note:** The variable `$cluster_address` refers to the FQDN or IPv4 address of the Rubrik cluster.
    ```bash
    curl -X GET "https://$cluster_address/api/v1/windows_cluster"
    ```
    The Rubrik REST API server responds with a ListResponse object that contains the first page of the list of WSFC clusters.
    ```bash
    {
      "hasMore": false,
      "data": [
        {
          "id": "$wsfc_id",
          "name": "$wsfc_name",
          "fqdn": "$wsfc_fqdn",
          "hostIds": [
            "$wsfc_node_id0",
            "$wsfc_node_id1"
          ],
          "primaryClusterId": "$cluster_id"
        }
      ],
      "total": 1
    }
    ```
    To retrieve detailed information about a WSFC cluster, send a GET request to: [`/windows_cluster/{id}`](#operation/getWindowsCluster), where `$cluster_id` is the `id` of the WSFC cluster.
    ```bash
    curl -X GET "https://$cluster_address/api/v1/windows_cluster/$cluster_id"
    ```
    The Rubrik REST API server responds with the details for the specified WSFC cluster.
    ```bash
    {
      "name": "$wsfc_name",
      "id": "$wsfc_id",
      "naturalId": "$cluster_natural_id",
      "hostIds": [
      "$wsfc_node_id0",
      "$wsfc_node_id1"
      ],
      "fqdn": "$wsfc_fqdn",
      "primaryClusterId": "$cluster_id"
    }
    ```
    # Filesets
    A fileset defines a set of files and folders on a Linux host or on a Windows host. The Rubrik cluster uses the filesets that are assigned to a host to determine the data to protect on that host.
    The Rubrik cluster interprets a fileset based on the values provided in the
    Include, Exclude, and Do Not Exclude arrays. The Rubrik cluster applies a
    set of rules to the values provided in these arrays and permits several
    types of values to be added to the arrays. The Do Not Exclude array specifies objects that should not be excluded from the fileset by the values in the Exclude array.
    ## Fileset workflow
    The basic workflow to follow when using filesets to protect data in host file systems is:
    1. Obtain and install the Rubrik Backup Service software on the host.
    The Rubrik user guide describes this task.
    2. Add the host to the Rubrik cluster.
    The [Hosts](#section/Hosts) section describes this task.
    3. Create a fileset template that defines a set of file system data to protect.
    The [Fileset templates](#section/Filesets/fileset_templates) section describes this task.
    4. Use a fileset template to assign a fileset to a host.
    5. Assign the host fileset to an SLA Domain.
    ## Fileset templates
    To get the current list of hosts we GET on the [`/fileset_template`](#operation/queryFilesetTemplate) endpoint.
    ```bash
    curl -X POST \
      -d '{
        "hostname": "$hostname" }' \
      "https://$cluster_address/api/v1/host"
    ```
    ```bash
    {
      "id": "$host_id",
      "hostname": "$hostname",
      "status": "Connected"
    }
    ```
    To get the current further details of hosts we GET on the [`/fileset_template/{id}`](#operation/getFilesetTemplate) endpoint.
    ```bash
    curl -X POST \
      -d '{
        "hostname": "$hostname" }' \
      "https://$cluster_address/api/v1/host"
    ```
    ```bash
    {
      "id": "$host_id",
      "hostname": "$hostname",
      "status": "Connected"
    }
    ```
    First create a fileset template.
    A fileset template can be used to create fileset instances for various hosts.
    Performing a POST on [`/fileset_template`](#operation/createFilesetTemplate)  with the necessary details will create a fileset template.
    ```bash
    curl -X POST \
      -d '{
        "name": "Users",
        "includes": ["C:\\Users"],
        "operatingSystemType": "Windows"}' \
      "https://$cluster_address/api/v1/fileset_template"
    ```
    ```bash
    {
      "id": "$fileset_template_id",
      "name": "Users",
      "excludes": [],
      "operatingSystemType": "Windows",
      "includes": [
        "C:\\Users"
      ]
    }
    ```
    Modify with PATCH on the [`/fileset_template/{id}`](#operation/updateFilesetTemplate) endpoint.
    ```bash
    curl -X POST \
      -d '{
        "hostname": "$hostname" }' \
      "https://$cluster_address/api/v1/host"
    ```
    ```bash
    {
      "id": "$host_id",
      "hostname": "$hostname",
      "status": "Connected"
    }
    ```
    Delete with n the [`/fileset_template/{id}`](#operation/deleteFilesetTemplate) endpoint.
    ```bash
    curl -X DELETE \
      -d '{
        "hostname": "$hostname" }' \
      "https://$cluster_address/api/v1/host"
    ```
    ## Fileset
    Using a fileset template, a fileset can be created.
    The fileset is an instance of the template that is assigned to a specific host.
    To get the current list of hosts we GET on the [`/fileset`](#operation/queryFileset) endpoint.
    ```bash
    curl -X POST \
      -d '{
        "hostname": "$hostname" }' \
      "https://$cluster_address/api/v1/host"
    ```
    ```bash
    {
      "id": "$host_id",
      "hostname": "$hostname",
      "status": "Connected"
    }
    ```
    To get the current further details of hosts we GET on the [`/fileset/{id}`](#operation/getFileset) endpoint.
    ```bash
    curl -X POST \
      -d '{
        "hostname": "$hostname" }' \
      "https://$cluster_address/api/v1/host"
    ```
    ```bash
    {
      "id": "$host_id",
      "hostname": "$hostname",
      "status": "Connected"
    }
    ```
    A fileset can be created with a POST on [`/fileset`](#operation/createFileset).
    ```bash
    curl -X POST \
      -d '{
        "templateId": "$fileset_template_id",
        "hostId": "$host_id" }' \
      "https://$cluster_address/api/v1/fileset"
    ```
    ```bash
    {
      "id": "$fileset_id",
      "excludes": [],
      "operatingSystemType": "Windows",
      "includes": [
        "C:\\Users"
      ],
      "hostId": "$host_id",
      "templateId": "$fileset_template_id",
      "configuredSlaDomainId": "UNPROTECTED"
    }
    ```
    A fileset can be deleted with a DELETE on [`/fileset`](#operation/deleteFileset).
    ```bash
    curl -X POST \
      -d '{
        "templateId": "fileset_template_id",
        "hostId": "$host_id" }' \
      "https://$cluster_address/api/v1/fileset"
    ```
    ```bash
    {
      "id": "$fileset_id",
      "excludes": [],
      "operatingSystemType": "Windows",
      "includes": [
        "C:\\Users"
      ],
      "hostId": "$host_id",
      "templateId": "$fileset_template_id",
      "configuredSlaDomainId": "UNPROTECTED"
    }
    ```
    ## On demand backups of host filesets
    To create an on-demand snapshot POST on [`/fileset/{id}/snapshot`](#operation/createFilesetBackupJob).
    ```bash
    curl -X POST \
      "https://$cluster_address/api/v1/fileset/$fileset_id/snapshot"
    ```
    ```bash
    {
      "id": "$request_id",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/fileset/request/$request_id",
          "rel": "self"
        }
      ],
      "status": "QUEUED"
    }
    ```
    Once the snapshot has been taken you should be able to retrieve the `$snapshot_id` by querying [`/fileset/request`](#operation/getFilesetAsyncRequestStatus).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/fileset/request/$request_id"
    ```
    ```bash
    {
      "id": "$request_id",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id",
          "rel": "result"
        },
        {
          "href": "https://$cluster_address/api/v1/fileset/request/$request_id",
          "rel": "self"
        }
      ],
      "status": "SUCCEEDED"
    }
    ```
    Once the snapshot has been taken you should be able to retrieve the `$snapshot_id` from the request.
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/fileset/request/$request_id"
    ```
    ```bash
    {
      "id": "$request_id",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id",
          "rel": "result"
        },
        {
          "href": "https://$cluster_address/api/v1/fileset/request/$request_id",
          "rel": "self"
        }
      ],
      "status": "SUCCEEDED"
    }
    ```
    Individual snapshots can be deleted with DELETE on [`/fileset/snapshot/{id}`](#operation/deleteFilesetSnapshot).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id"
    ```
    ```bash
    {
    }
    ```
    Delete all snapshots for a specific vm with a DELETE on [`/fileset/{id}/snapshot`](#operation/deleteFilesetSnapshots).
    ```bash
    curl -X DELETE "https://$cluster_address/api/v1/fileset/$vm_id/snapshot"
    ```
    ## SLA Domain protection of host filesets
    Assign a fileset to an SLA with a PATCH [`/fileset/{id}`](#operation/updateFileset).
    ```bash
    curl -X PATCH \
      -d '{
        "configuredSlaDomainId": "$sla_domain_id" }' \
      "https://$cluster_address/api/v1/fileset/$fileset_id"
    ```
    ```bash
    {
      "id": "$fileset_id",
      "excludes": [],
      "operatingSystemType": "Windows",
      "includes": [
        "C:\\Users"
      ],
      "hostId": "$host_id",
      "templateId": "$fileset_template_id",
      "configuredSlaDomainId": "$sla_domain_id"
    }
    ```
    Missed snapshot with a GET on [`/fileset/{id}/missed_snapshot`](#operation/getMissedFilesetSnapshots).
    ```bash
    curl -X GET "https://$cluster_address/api/v1/fileset/$vm_id/missed_snapshot"
    ```
    ```bash
    {
      "hasMore": true,
      "data": [
        {
          "missedSnapshotTime": "2000-01-02T11:08:40.420Z"
        }
      ],
      "total": 1
    }
    ```
    ## Search &amp; Recovery
    Once snapshots have been taken, they can be used to search for files and recover.
    A host-level file search can be performed with a GET on [`/host/{id}/search`](#operation/searchHost).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/host/$host_id/search?path=home"
    ```
    ```bash
    {
      "hasMore": false,
      "data": [
        {
          "path": "/home",
          "filename": "home",
          "fileVersions": [
            {
              "snapshotId": "$snapshot_id",
              "lastModified": "2014-07-17T02:02:54+0000",
              "size": 533120
            }
          ]
        }
      ],
      "total": 1
    }
    ```
    File search can be performed on a specific fileset using its `$fileset_id` with a GET on [`/fileset/{id}/search`](#operation/searchFileset) and specifying the file path with the `path` query parameter.
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/fileset/$fileset_id/search?path=home"
    ```
    ```bash
    {
      "hasMore": false,
      "data": [
        {
          "path": "/home",
          "filename": "home",
          "fileVersions": [
            {
              "snapshotId": "$snapshot_id",
              "lastModified": "2014-07-17T02:02:54+0000",
              "size": 533120
            }
          ]
        }
      ],
      "total": 1
    }
    ```
    Given the snapshot one can browse files within the snapshot with GET on [`/fileset/snapshot/{id}/browse`](#operation/browseFilesetSnapshot).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/browse?path=%2Fhome&amp;offset=0"
    ```
    ```bash
    {
      "hasMore": false,
      "data": [
        {
          "filename": "ubuntu",
          "path": "ubuntu",
          "lastModified": "2016-12-01T23:26:59+0000",
          "size": 529024,
        }
      ],
      "total": 1
    }
    ```
    To retrieve files from the snapshot we can either download the entire snapshot or just individual files.
    A entire snapshot can be downloaded with POST on [`/fileset/snapshot/{id}/download`](#operation/createDownloadFilesetSnapshotFromCloud).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id"
    ```
    Also individual files can be downloaded with POST on [`/fileset/snapshot/{id}/download`](#operation/createFilesetDownloadFileJob).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/download_file"
    ```
    Both [`/fileset/snapshot/{id}/download`](#operation/createDownloadFilesetSnapshotFromCloud) and [`/fileset/snapshot/{id}/download`](#operation/createFilesetDownloadFileJob) return an async request that can be polled to retrieve the eventual download location.
    ```bash
    curl -X GET "https://$cluster_address/api/v1/fileset/request/$request_id"
    ```
    ```bash
    {
      "id": "$request_id",
      "links": [
        {
          "href": "$download_url",
          "rel": "result"
        },
        {
          "href": "https://$cluster_address/api/v1/fileset/request/$request_id",
          "rel": "self"
        }
      ],
      "status": "QUEUED"
    }
    ```
    Files from a snapshot can also be restored to a host with POST on [`/fileset/snapshot/{id}/restore_file`](#operation/createFilesetRestoreFileJob).
    ```bash
    curl -X POST -d \
      '{
        "sourceDir": "/foo.txt",
        "destinationDir": "/bar.txt"
      }' \
      "https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/download_file"
    ```
    Files can also be restored to a different host with POST on [`/fileset/snapshot/{id}/export_file`](#operation/createFilesetExportFileJob).
    ```bash
    curl -X POST -d \
      '{
        "sourceDir": "/foo.txt",
        "destinationDir": "/bar.txt",
        "hostId": "$host_id"
      }' \
      "https://$cluster_address/api/v1/fileset/snapshot/$snapshot_id/download_file"
    ```
    # SQL Server databases
    Version 3.0 added support for Microsoft SQL backups.
    First add the hosts hosting the Microsoft SQL databases as specified in the [host protection](#section/Hosts) section.
    Once the host has been added, instances and databases will be auto-discovered.
    ## Instances
    Microsoft SQL instances can be found by a GET on [`/mssql/instance`](#operation/queryMssqlInstance)
    ```bash
    curl -X GET "https://$cluster_address/api/v1/mssql/instance"
    ```
    ```bash
    {
      "data": [
        {
          "id": "$instance_id",
          "name": "$instance_name",
          "configuredSlaDomainId": "INHERIT",
          "configuredSlaDomainName": "Inherit",
          "effectiveSlaDomainId": "INHERIT",
          "effectiveSlaDomainName": "Inherit"
        }
      ],
      "hasMore": false,
      "total": 1
    }
    ```
    Further details are acquired from [`/mssql/instance/{id}`](#operation/getMssqlInstance).
    ```bash
    curl -X GET "https://$cluster_address/api/v1/mssql/instance/$instance_id"
    ```
    ```bash
    {
      "data": [
        {
          "id": "$instance_id",
          "name": "$instance_name",
          "configuredSlaDomainId": "INHERIT",
          "configuredSlaDomainName": "Inherit",
          "effectiveSlaDomainId": "UNPROTECTED",
          "effectiveSlaDomainName": "Unprotected"
        }
      ],
      "hasMore": false,
      "total": 1
    }
    ```
    The Rubrik cluster auto-detects most fields of the Microsoft SQL instance. However, certain fields such as the `clusterInstanceAddress` can be overridden with a PATCH to [`/mssql/instance/{id}`](#operation/updateMssqlInstance).
    ```bash
    curl -X PATCH \
      -d '{
        "clusterInstanceAddress": "1.1.1.1"
      }' \
      "https://$cluster_address/api/v1/mssql/instance/$instance_id"
    ```
    ```bash
    {
      "data": [
        '{
          "id": "$instance_id",
          "name": "$instance_name",
          "configuredSlaDomainId": "INHERIT",
          "configuredSlaDomainName": "Inherit",
          "effectiveSlaDomainId": "UNPROTECTED",
          "effectiveSlaDomainName": "Unprotected",
          "clusterInstanceAddress": "1.1.1.1"
      }' \
        }
      ],
      "hasMore": false,
      "total": 1
    }
    ```
    ## Databases
    All Microsoft SQL databases on an instance can be found with a GET on [`/mssql/db`](#operation/queryMssqlDb).
    ```bash
    curl -X GET "https://$cluster_address/api/v1/mssql/db?instance_id=$instance_id"
    ```
    ```bash
    {
      "data": [
        {
          "id": "$db_id",
          "name": "$db_name",
          "configuredSlaDomainId": "INHERIT",
          "configuredSlaDomainName": "Inherit",
          "effectiveSlaDomainId": "UNPROTECTED",
          "effectiveSlaDomainName": "Unprotected",
          "instanceId": "$instance_id"
          "instanceName": "$instance_name"
        }
      ],
      "hasMore": false,
      "total": 1
    }
    ```
    Further details are acquired from [`/mssql/db/{id}`](#operation/getMssqlDb).
    ```bash
    curl -X GET "https://$cluster_address/api/v1/mssql/db/$db_id"
    ```
    ```bash
    {
      "data": [
        {
          "id": "$db_id",
          "name": "$db_name",
          "configuredSlaDomainId": "INHERIT",
          "configuredSlaDomainName": "Inherit",
          "effectiveSlaDomainId": "UNPROTECTED",
          "effectiveSlaDomainName": "Unprotected",
          "instanceId": "$instance_id"
          "instanceName": "$instance_name"
        }
      ],
      "hasMore": false,
      "total": 1
    }
    ```
    ## Protection
    To create an on-demand snapshot, POST on [`/mssql/db/{id}/snapshot`](#operation/createOnDemandMssqlBackup).
    ```bash
    curl -X POST \
      "https://$cluster_address/api/v1/mssql/db/$db_id/snapshot"
    ```
    ```bash
    {
      "id": "$request_id",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/mssql/db/request/$request_id",
          "rel": "self"
        }
      ],
      "status": "QUEUED"
    }
    ```
    Once the snapshot has been taken, the `$snapshot_id` can be retrieved from the request with [`/mssql/request/{id}`](#operation/getMssqlAsyncRequestStatus).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/mssql/request/$request_id"
    ```
    ```bash
    {
      "id": "$request_id",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/mssql/db/snapshot/$snapshot_id",
          "rel": "result"
        },
        {
          "href": "https://$cluster_address/api/v1/mssql/request/$request_id",
          "rel": "self"
        }
      ],
      "status": "SUCCEEDED"
    }
    ```
    The `$snapshot_id` can be used to extract further information on the snapshot with a GET on [`/mssql/db/snapshot/{id}`](#operation/getMssqlDbSnapshot).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/mssql/db/snapshot/$snapshot_id"
    ```
    ```bash
    {
      "id": "$snapshot_id",
      "date": "2017-02-02T18:53:12.718Z",
      "isOnDemandSnapshot": true
    }
    ```
    To protect a specific database under an SLA, perform a PATCH on [`/mssql/db/{id}`](#operation/updateMssqlDb)
    ```bash
    curl -X PATCH \
      -d '{
        "configuredSlaDomainId": "$sla_domain_id" }' \
      "https://$cluster_address/api/v1/mssql/db/$db_id"
    ```
    ```bash
    {
      "id": "$db_id",
      "name": "$db_name",
      "configuredSlaDomainId": "$sla_domain_id",
      "configuredSlaDomainName": "$sla_domain_name",
      "effectiveSlaDomainId": "$sla_domain_id",
      "effectiveSlaDomainName": "sla_domain_name",
      "instanceId": "$instance_id"
      "instanceName": "$instance_name"
    }
    ```
    List all snapshots for a database with a GET on [`/mssql/db/{id}/snapshot`](#operation/queryMssqlDbSnapshot).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/mssql/db/$db_id/snapshot"
    ```
    ```bash
    {
      "hasMore": true,
      "data": [
        {
          "id": "$snapshot_id",
          "date": "2017-02-02T18:53:12.718Z",
          "isOnDemandSnapshot": true
        }
      ],
      "total": 1
    }
    ```
    Point-in-time recovery is supported when log backups are taken. The range of recoverable times can be listed with a GET on [`/mssql/db/{id}/recoverable_range`](#operation/getMssqlDbRecoverableRanges).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/mssql/db/$db_id/recoverable_range"
    ```
    ```bash
    {
      "hasMore": true,
      "data": [
        {
          "beginTime": "2017-02-02T18:53:12.694Z",
          "endTime": "2017-02-02T20:53:12.694Z"
        }
      ],
      "total": 1
    }
    ```
    It is possible that certain snapshots fail to be taken as per the SLA policy.
    Query any missed snapshot information with a GET on [`/msssql/db/{id}/missed_snapshot`](#operation/getMissedMssqlDbSnapshots).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/msssql/db/$db_id/missed_snapshot"
    ```
    ```bash
    {
      "hasMore": true,
      "data": [
        {
          "missedSnapshotTime": "2000-01-02T11:08:40.420Z"
        }
      ],
      "total": 1
    }
    ```
    Missed recoverable time ranges can be queried with a GET on [`/msssql/db/{id}/missed_recoverable_range`](#operation/getMssqlDbMissedRecoverableRanges).
    ```bash
    curl -X GET \
      "https://$cluster_address/api/v1/msssql/db/$db_id/missed_recoverable_range"
    ```
    ```bash
    {
      "hasMore": true,
      "data": [
        {
          "beginTime": "2017-02-02T18:53:12.694Z",
          "endTime": "2017-02-02T20:53:12.694Z"
        }
      ],
      "total": 1
    }
    ```
    Delete all snapshots for a specific database with a DELETE on [`/mssql/db/{id}/snapshot`](#operation/deleteMssqlDbSnapshots).
    ```bash
    curl -X DELETE "https://$cluster_address/api/v1/mssql/db/$db_id/snapshot"
    ```
    ## Restore
    Perform a restore with a POST on [`/mssql/db/{id}/restore`](#operation/createRestoreMssqlDb) specifying the timestamp as the recovery point.
    ```bash
    curl -X POST -d \
      '{
        "recoveryPoint": {
          "timestampMs": 12345
        }
      }' \
      "https://$cluster_address/api/v1/mssql/db/$db_id/restore"
    ```
    A database can also be exported to another instance with a POST on [`/mssql/db/{id}/export`](#operation/createExportMssqlDb).
    ```bash
    curl -X POST -d \
      '{
        "recoveryPoint": {
          "timestampMs": 12345
        },
        "targetInstanceId": "$instance_id",
        "targetDatabaseName": "$db_name"
      }' \
      "https://$cluster_address/api/v1/mssql/db/$db_id/export"
    ```
    ## Live Mount
    Perform a Live Mount with a POST on [`/mssql/db/{id}/mount`](#operation/createMssqlMount), specifying the timestamp as the recovery point.
    ```bash
    curl -X POST -d \
      '{
        "recoveryPoint": {
          "timestampMs": 12345
        },
        "mountedDatabaseName": "$db_name"
      }' \
      "https://$cluster_address/api/v1/mssql/db/$db_id/mount"
    ```
    All current Live Mounts can be found with a GET on [`/mssql/db/mount`](#operation/queryMssqlMount).
    ```bash
    curl -X GET "https://$cluster_address/api/v1/mssql/db/mount"
    ```
    ```bash
    {
      "hasMore": true,
      "data": [
        {
          "id": "$mount_id",
          "sourceDatabaseId": "$source_db_id",
          "sourceRecoveryPoint": {
            "timestampMs": 12345
          },
          "targetInstanceId": "$target_instance_id",
          "creationDate": "2017-02-02T18:53:12.694Z",
          "isReady": true,
          "mountedDatabaseId": "$mounted_db_id"
        }
      ],
      "total": 1
    }
    ```
    Further details for a single Live Mount are acquired from [`/mssql/db/mount/{id}`](#operation/getMssqlMount).
    ```bash
    curl -X GET "https://$cluster_address/api/v1/mssql/db/mount/$mount_id"
    ```
    ```bash
    {
      "id": "$mount_id",
      "sourceDatabaseId": "$source_db_id",
      "sourceRecoveryPoint": {
        "timestampMs": 12345
      },
      "targetInstanceId": "$target_instance_id",
      "creationDate": "2017-02-02T18:53:12.694Z",
      "isReady": true,
      "mountedDatabaseId": "$mounted_db_id",
      "links": [
        {
          "href": "https://$cluster_address/api/v1/mssql/db/$source_db_id",
          "rel": "sourceDatabase"
        },
        {
          "href": "https://$cluster_address/api/v1/mssql/instance/$target_instance_id",
          "rel": "targetInstance"
        },
        {
          "href": "https://$cluster_address/api/v1/mssql/db/$mounted_db_id",
          "rel": "mountedDatabase"
        }
      ],
    }
    ```
    Delete a Live Mount with a DELETE on [`/mssql/db/mount/{id}`](#operation/createMssqlUnmount).
    ```bash
    curl -X DELETE "https://$cluster_address/api/v1/mssql/db/mount/$mount_id"
    ```
    # Legal
    ## Copyright
    Rubrik REST API - Copyright © 2017 Rubrik Inc.
    All rights reserved.
    This documentation may be used free of charge. Selling without prior written consent is prohibited.
    Obtain permission before redistributing. In all cases, this copyright notice and disclaimer must remain
    intact.
    ## Disclaimer
    THE CONTENTS OF THIS DOCUMENTATION ARE PROVIDED "AS IS," AND COPYRIGHT HOLDERS MAKE NO
    REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
    WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, OR
    TITLE; THAT THE CONTENTS OF THE DOCUMENTATION ARE SUITABLE FOR ANY PURPOSE; THAT THE
    IMPLEMENTATION OF SUCH CONTENTS WILL NOT INFRINGE ANY THIRD PARTY PATENTS, COPYRIGHTS,
    TRADEMARKS OR OTHER RIGHTS.
    COPYRIGHT HOLDERS WILL NOT BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL OR CONSEQUENTIAL
    DAMAGES ARISING OUT OF ANY USE OF THE DOCUMENTATION OR THE PERFORMANCE OR IMPLEMENTATION OF
    THE CONTENTS THEREOF.
    ## Trademarks
    Rubrik, the Rubrik logo, Rubrik Envision, and Rubrik Edge are trademarks or registered trademarks of Rubrik, Inc. in the U.S. and/or other countries. All other trademarks are the property of their respective owners.

    :ivar config: Configuration for client.
    :vartype config: RubrikLibConfiguration

    :param str base_url: Service URL
    """

    def __init__(
            self, base_url=None):

        self.config = RubrikLibConfiguration(base_url)
        self._client = ServiceClient(None, self.config)

        client_models = {k: v for k, v in models.__dict__.items() if isinstance(v, type)}
        self.api_version = '1'
        self._serialize = Serializer(client_models)
        self._deserialize = Deserializer(client_models)


    def get_public_cluster_info(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get cluster details.

        Retrieve public information about the Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ClusterInfo <rubriklib.models.ClusterInfo>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ClusterInfo <rubriklib.models.ClusterInfo>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/cluster/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ClusterInfo', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_cluster_version(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get cluster software version.

        Retrieves software version of the Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ClusterVersion <rubriklib.models.ClusterVersion>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ClusterVersion <rubriklib.models.ClusterVersion>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/cluster/{id}/version'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ClusterVersion', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_cluster_api_version(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Get cluster REST API version.

        Retrieves software version of the Rubrik cluster.

        :param id: ID of the Rubrik cluster or *me* for self
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`ClusterApiVersion
         <rubriklib.models.ClusterApiVersion>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`ClusterApiVersion
         <rubriklib.models.ClusterApiVersion>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/cluster/{id}/api_version'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('ClusterApiVersion', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_fileset(
            self, primary_cluster_id=None, host_id=None, share_id=None, is_relic=None, effective_sla_domain_id=None, template_id=None, limit=None, offset=None, name=None, host_name=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for all filesets.

        Retrieve summary information for each fileset. Optionally, filter the
        retrieved information.

        :param primary_cluster_id: Filter the summary information based on the
         primary_cluster_id of the primary Rubrik cluster.
         Use **_local_** as the primary_cluster_id of the Rubrik cluster that
         is hosting the current REST API session.
        :type primary_cluster_id: str
        :param host_id: Filter the summary information based on the ID of the
         host referenced by the fileset.
        :type host_id: str
        :param share_id: Filter the summary information based on the ID of the
         host share referenced by the fileset.
         Use **_NONE_** to only return information for filesets that were not
         created based on a host share.
         Use **_ANY_** to only return information for filesets that were
         created based on a host share.
        :type share_id: str
        :param is_relic: Filter the summary information based on the relic
         status of the fileset. Returns both relic and non relic if the
         parameter is not set.
        :type is_relic: bool
        :param effective_sla_domain_id: Filter the summary information based
         on the ID of the effective SLA Domain inherited by a fileset.
         Use **_UNPROTECTED_** to only return information for filesets that do
         not have an effective SLA Domain.
         Use **_PROTECTED_** to only return information for filesets that do
         have an effective SLA Domain.
        :type effective_sla_domain_id: str
        :param template_id: Filter the summary information based on the ID of
         a fileset template.
         Use **_NONE_** to only return information for filesets that were not
         created from a fileset template.
         Use **_ANY_** to only return information for filesets that were
         created from a fileset template.
        :type template_id: str
        :param limit: Limit the summary information to a specified maximum
         number of filesets.
         Optionally, use with **_offset_** to start the count at a specified
         point.
         Optionally, use with **_sort_by_** to perform sort on given
         attributes. Include **_sort_order_** to determine the ascending or
         descending direction of sort.
        :type limit: int
        :param offset: Starting position in the list of fileset entries
         contained in the response. The summary information includes the
         specified numbered entry and all higher numbered entries. Use with
         **_limit_** to retrieve the summary information as smaller groups of
         entries, e.g. for paging of results.
        :type offset: int
        :param name: Retrieve filesets with a name matching the provided name.
         The search is performed as a case-insensitive infix search.
        :type name: str
        :param host_name: Retrieve filesets with a host name matching the
         provided name. The search is performed as a case-insensitive infix
         search.
        :type host_name: str
        :param sort_by: Specifies a comma-separated list of fileset attributes
         to use in sorting the fileset summary information. Performs an ASCII
         sort of the summary information using each specified attribute, in the
         order specified.
         Valid attributes are: **_name_**, **_hostName_**, **_templateType_**,
         **_slaName_**, **_includes_**, **_excludes_**, and **_exceptions_**.
         Requires **_sort_order_**. Possible values include: 'name',
         'hostName', 'templateId', 'effectiveSlaDomainName', 'includes',
         'excludes', 'exceptions'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FilesetSummaryListResponse
         <rubriklib.models.FilesetSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FilesetSummaryListResponse
         <rubriklib.models.FilesetSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset'

        # Construct parameters
        query_parameters = {}
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if host_id is not None:
            query_parameters['host_id'] = self._serialize.query("host_id", host_id, 'str')
        if share_id is not None:
            query_parameters['share_id'] = self._serialize.query("share_id", share_id, 'str')
        if is_relic is not None:
            query_parameters['is_relic'] = self._serialize.query("is_relic", is_relic, 'bool')
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if template_id is not None:
            query_parameters['template_id'] = self._serialize.query("template_id", template_id, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if host_name is not None:
            query_parameters['host_name'] = self._serialize.query("host_name", host_name, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FilesetSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_fileset(
            self, definition, custom_headers=None, raw=False, **operation_config):
        """Create one fileset for a host.

        Create a fileset for a network host. A fileset is a fileset template
        applied to a host.

        :param definition: Specify a host id and a template id
        :type definition: :class:`FilesetCreate
         <rubriklib.models.FilesetCreate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FilesetDetail <rubriklib.models.FilesetDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FilesetDetail <rubriklib.models.FilesetDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'FilesetCreate')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('FilesetDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_fileset(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get information for a single fileset.

        Retrieve summary information for a fileset by specifying the fileset
        ID.

        :param id: Specify the fileset ID.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FilesetDetail <rubriklib.models.FilesetDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FilesetDetail <rubriklib.models.FilesetDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FilesetDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_fileset(
            self, id, fileset_update_properties, custom_headers=None, raw=False, **operation_config):
        """Update a Fileset.

        Update a Fileset with the specified properties.

        :param id: ID of the Fileset to update.
        :type id: str
        :param fileset_update_properties: Properties to update.
        :type fileset_update_properties: :class:`FilesetUpdate
         <rubriklib.models.FilesetUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FilesetDetail <rubriklib.models.FilesetDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FilesetDetail <rubriklib.models.FilesetDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(fileset_update_properties, 'FilesetUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FilesetDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_fileset(
            self, id, preserve_snapshots=None, custom_headers=None, raw=False, **operation_config):
        """Delete a fileset.

        Delete a fileset by specifying the fileset ID.

        :param id: Provide a fileset ID to delete.
        :type id: str
        :param preserve_snapshots: Flag to indicate whether to preserve
         snapshots of the fileset or to delete them. Default behavior is to
         preserve them.
        :type preserve_snapshots: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if preserve_snapshots is not None:
            query_parameters['preserve_snapshots'] = self._serialize.query("preserve_snapshots", preserve_snapshots, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204, 404]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def get_missed_fileset_snapshots(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get missed snapshots for a fileset.

        Retrieve summary information about all missed snapshots for a fileset.

        :param id: ID of the fileset.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MissedSnapshotListResponse
         <rubriklib.models.MissedSnapshotListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MissedSnapshotListResponse
         <rubriklib.models.MissedSnapshotListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/{id}/missed_snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MissedSnapshotListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def search_fileset(
            self, id, path, custom_headers=None, raw=False, **operation_config):
        """Search for a file within the fileset.

        Search for a file within the fileset. Search via full path prefix or
        filename prefix.

        :param id: Fileset ID to search
        :type id: str
        :param path: The path query. Either path prefix or filename prefix.
        :type path: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SearchResponseListResponse
         <rubriklib.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SearchResponseListResponse
         <rubriklib.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/{id}/search'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['path'] = self._serialize.query("path", path, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SearchResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_fileset_backup_job(
            self, id, config=None, custom_headers=None, raw=False, **operation_config):
        """Initiate an on-demand backup for a fileset.

        Create an on-demand backup request for the given fileset.

        :param id: ID of the Fileset
        :type id: str
        :param config: Configuration for the on-demand backup.
        :type config: :class:`BaseOnDemandSnapshotConfig
         <rubriklib.models.BaseOnDemandSnapshotConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if config is not None:
            body_content = self._serialize.body(config, 'BaseOnDemandSnapshotConfig')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_fileset_snapshots(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete all snapshots of a fileset.

        Delete all snapshots that were created based on a fileset by providing
        the fileset ID.
        Requires an unprotected fileset. Remove the fileset from all SLA
        Domains.

        :param id: ID of the fileset.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def delete_fileset_snapshot(
            self, id, location, custom_headers=None, raw=False, **operation_config):
        """Delete a fileset snapshot.

        Delete a fileset snapshot. A snapshot is deleted only if it is an
        on-demand snapshot, a snapshot of an unprotected fileset or a local
        snapshot that was downloaded from an archive location.

        :param id: ID of snapshot
        :type id: str
        :param location: Snapshot location to delete. Use **_local_** to
         delete all local snapshots and **_all_** to delete the snapshot in all
         locations. Possible values include: 'all', 'local'
        :type location: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/snapshot/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['location'] = self._serialize.query("location", location, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def browse_fileset_snapshot(
            self, id, path, offset=None, limit=None, custom_headers=None, raw=False, **operation_config):
        """Lists all files and directories in a given path.

        Lists all files and directories in a given path.

        :param id: ID of snapshot
        :type id: str
        :param path: The absolute path of the starting point for the directory
         listing.
        :type path: str
        :param offset: Starting position in the list of path entries contained
         in the query results, sorted by lexicographical order. The response
         includes the specified numbered entry and all higher numbered entries.
        :type offset: int
        :param limit: Maximum number of entries in the response.
        :type limit: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`BrowseResponseListResponse
         <rubriklib.models.BrowseResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`BrowseResponseListResponse
         <rubriklib.models.BrowseResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/snapshot/{id}/browse'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['path'] = self._serialize.query("path", path, 'str')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BrowseResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_download_fileset_snapshot_from_cloud(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Create a download fileset snapshot from archival request.

        Create a download fileset snapshot from archival request.

        :param id: ID of snapshot
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/snapshot/{id}/download'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_fileset_download_file_job(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Create a file download job from a fileset backup.

        Initiate a job to download a file from a backup of a fileset. Returns a
        job instance ID.
        To retrieve the file, use GET /user_notification/{user_id} to monitor
        the job. When the download is ready, JobNotificationInfo includes the
        job instance ID as the value of **_jobId_** and the file download link
        as the value of DownloadFile.

        :param id: ID of snapshot
        :type id: str
        :param config: Configuration for a download job.
        :type config: :class:`FilesetDownloadFileJobConfig
         <rubriklib.models.FilesetDownloadFileJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/snapshot/{id}/download_file'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'FilesetDownloadFileJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_fileset_export_file_job(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Create export job.

        Initiate a job to copy a file or folder from a fileset backup to a
        destination host other than the source host. Returns the job instance
        ID.

        :param id: ID of snapshot
        :type id: str
        :param config: Configuration for job to export a file or folder from a
         fileset backup.
        :type config: :class:`FilesetExportFileJobConfig
         <rubriklib.models.FilesetExportFileJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/snapshot/{id}/export_file'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'FilesetExportFileJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_fileset_restore_file_job(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Create restore job.

        Initiate a job to copy a file or folder from a fileset backup to the
        source host. Returns the job instance ID.

        :param id: ID of snapshot
        :type id: str
        :param config: Configuration for job to restore a file or folder from
         a fileset backup.
        :type config: :class:`FilesetRestoreFileJobConfig
         <rubriklib.models.FilesetRestoreFileJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/snapshot/{id}/restore_file'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'FilesetRestoreFileJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_fileset_async_request_status(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details about an async request.

        Get details about a fileset related async request.

        :param id: ID of the request
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset/request/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_fileset_template(
            self, primary_cluster_id=None, operating_system_type=None, share_type=None, name=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for all fileset templates.

        Retrieve summary information for all fileset templates, including: ID
        and name of the fileset template, fileset template creation timestamp,
        array of the included filepaths, array of the excluded filepaths.

        :param primary_cluster_id: Filter the summary information based on the
         primary_cluster_id of the primary Rubrik cluster.
         Use **_local_** as the primary_cluster_id of the Rubrik cluster that
         is hosting the current REST API session.
        :type primary_cluster_id: str
        :param operating_system_type: Filter the summary information based on
         the operating system type of the fileset. Accepted values: 'Windows',
         'Linux', 'ANY', 'NONE'.
         Use **_NONE_** to only return information for fileset templates that
         do not have operating system type set.
         Use **_ANY_** to only return information for fileset templates that
         have operating system type set. Possible values include: 'Linux',
         'Windows', 'ANY', 'NONE'
        :type operating_system_type: str
        :param share_type: Filter the summary information based on the share
         type where the fileset is assigned to. Accepted values: 'NFS', 'SMB',
         'ANY', 'NONE'.
         Use **_NONE_** to only return information for fileset templates that
         do not have share type set.
         Use **_ANY_** to only return information for fileset templates that
         have share type set. Possible values include: 'NFS', 'SMB', 'ANY',
         'NONE'
        :type share_type: str
        :param name: Retrieve fileset templates with a name matching the
         provided name. The search is performed as a case-insensitive infix
         search.
        :type name: str
        :param sort_by: Specifies a comma-separated list of fileset attributes
         to use in sorting the fileset summary information. Performs an ASCII
         sort of the summary information using each specified attribute, in the
         order specified.
         Valid attributes are: **_name_**, **_includes_**, **_excludes_**,
         **_exceptions_**, **_hostCount_**, **_shareType_**. Default sort_order
         is ascending. Possible values include: 'name', 'hostCount',
         'includes', 'excludes', 'exceptions', 'shareType'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FilesetTemplateDetailListResponse
         <rubriklib.models.FilesetTemplateDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FilesetTemplateDetailListResponse
         <rubriklib.models.FilesetTemplateDetailListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset_template'

        # Construct parameters
        query_parameters = {}
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if operating_system_type is not None:
            query_parameters['operating_system_type'] = self._serialize.query("operating_system_type", operating_system_type, 'str')
        if share_type is not None:
            query_parameters['share_type'] = self._serialize.query("share_type", share_type, 'str')
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FilesetTemplateDetailListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_fileset_template(
            self, definition, custom_headers=None, raw=False, **operation_config):
        """Create a fileset template.

        Create a fileset template. The template is applied to the host.  Each
        template is a set of paths on the host.
        A template uses full paths and wildcards to define the objects to
        include, exclude, and exempt from exclusion.
        The **_exceptions_** value specifies paths that should not be excluded
        from the fileset by the **_exclude_** value.
        Specify an array of full path descriptions for each property
        **_include_**, **_exclude_**, and **_exceptions_**.
        Acceptable wildcard characters are
        + **_\*_** Single asterisk matches zero or more characters up to a path
        deliminator
        + **_\*\*_** Double asterisk matches zero or more characters
        The following rules apply to path descriptions
        + Accepts UTF-8 characters
        + Case sensitive
        + Forward slash character **_/_** is the path deliminator
        + Symbolic links must point to a subset of a non symbolic link path
        + Paths that do not start with **_/_** are modified to start with
        **_\*\*/_**
        + Paths that do not end with **_\*_** are modified to end with
        **_/\*\*_**.

        :param definition: Provide an object with the fileset template
         definition.
        :type definition: :class:`FilesetTemplateCreate
         <rubriklib.models.FilesetTemplateCreate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FilesetTemplateDetail
         <rubriklib.models.FilesetTemplateDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FilesetTemplateDetail
         <rubriklib.models.FilesetTemplateDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset_template'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'FilesetTemplateCreate')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('FilesetTemplateDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_fileset_template(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get information for a fileset template.

        Retrieve summary information for a specified fileset template.

        :param id: The ID of the fileset template.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FilesetTemplateDetail
         <rubriklib.models.FilesetTemplateDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FilesetTemplateDetail
         <rubriklib.models.FilesetTemplateDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset_template/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FilesetTemplateDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_fileset_template(
            self, id, definition, custom_headers=None, raw=False, **operation_config):
        """Modify a fileset template.

        Modify the values of specified fileset template.

        :param id: ID of the fileset template to update.
        :type id: str
        :param definition: Provide an object with the fileset template
         definition.
        :type definition: :class:`FilesetTemplatePatch
         <rubriklib.models.FilesetTemplatePatch>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`FilesetTemplateDetail
         <rubriklib.models.FilesetTemplateDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`FilesetTemplateDetail
         <rubriklib.models.FilesetTemplateDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset_template/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'FilesetTemplatePatch')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('FilesetTemplateDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_fileset_template(
            self, id, preserve_snapshots=None, custom_headers=None, raw=False, **operation_config):
        """Delete a fileset template.

        Deletes the specfied fileset template. All associated filesets are
        deleted.

        :param id: ID of the fileset template to remove.
        :type id: str
        :param preserve_snapshots: Flag to indicate whether to convert
         snapshots of all filesets of this template to relics or to delete
         them.  Default is true.
        :type preserve_snapshots: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/fileset_template/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if preserve_snapshots is not None:
            query_parameters['preserve_snapshots'] = self._serialize.query("preserve_snapshots", preserve_snapshots, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def query_host(
            self, operating_system_type=None, primary_cluster_id=None, hostname=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for hosts.

        Retrieve summary information for all hosts that are registered with a
        Rubrik cluster.

        :param operating_system_type: Filter the summary information based on
         the operating system type. Accepted values are 'Windows', 'Linux',
         'ANY', 'NONE'.
         Use **_NONE_** to only return information for hosts templates that do
         not have operating system type set.
         Use **_ANY_** to only return information for hosts that have operating
         system type set. Possible values include: 'ANY', 'NONE', 'Linux',
         'Windows'
        :type operating_system_type: str
        :param primary_cluster_id: Filters the summary information based on
         the Rubrik cluster specified by the value of primary_cluster_id. Use
         'local' for the Rubrik cluster that is hosting the current REST API
         session.
        :type primary_cluster_id: str
        :param hostname: Retrieve hosts with a host name matching the provided
         name. The search type is infix
        :type hostname: str
        :param sort_by: Specifies the host attribute to use in sorting the
         host summary information. Performs an ASCII sort of the summary
         information using the specified attribute, in the order specified.
         Valid attributes are 'hostname'. Possible values include: 'hostname'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostSummaryListResponse
         <rubriklib.models.HostSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostSummaryListResponse
         <rubriklib.models.HostSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/host'

        # Construct parameters
        query_parameters = {}
        if operating_system_type is not None:
            query_parameters['operating_system_type'] = self._serialize.query("operating_system_type", operating_system_type, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if hostname is not None:
            query_parameters['hostname'] = self._serialize.query("hostname", hostname, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HostSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def register_host(
            self, host, custom_headers=None, raw=False, **operation_config):
        """Register a host.

        Register a host.

        :param host: Registration definition for a host.
        :type host: :class:`HostRegister <rubriklib.models.HostRegister>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostDetail <rubriklib.models.HostDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostDetail <rubriklib.models.HostDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/host'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(host, 'HostRegister')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('HostDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_host(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get summary information for a host.

        Retrieve summary information for a registered host.

        :param id: ID of the registered host.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostDetail <rubriklib.models.HostDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostDetail <rubriklib.models.HostDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/host/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HostDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_host(
            self, id, host_update_properties, custom_headers=None, raw=False, **operation_config):
        """Modify information for a registered host.

        Change the FQDN or IPv4 value used to connect with a registered host.
        Optionally, specify whether to compress data before transfer.

        :param id: ID of the registered host
        :type id: str
        :param host_update_properties: Properties of host to update
        :type host_update_properties: :class:`HostUpdate
         <rubriklib.models.HostUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`HostDetail <rubriklib.models.HostDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`HostDetail <rubriklib.models.HostDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/host/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(host_update_properties, 'HostUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('HostDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_host(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete a registered host.

        Delete host by specifying the host ID.

        :param id: ID of the host to delete
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/host/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def search_host(
            self, id, path, custom_headers=None, raw=False, **operation_config):
        """Search for a file within the host.

        Search for a file within the host. Search via full path prefix or
        filename prefix.

        :param id: ID of the host to search
        :type id: str
        :param path: The path query. Either path prefix or filename prefix.
        :type path: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SearchResponseListResponse
         <rubriklib.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SearchResponseListResponse
         <rubriklib.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/host/{id}/search'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['path'] = self._serialize.query("path", path, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SearchResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_mssql_db(
            self, instance_id=None, effective_sla_domain_id=None, primary_cluster_id=None, is_relic=None, is_live_mount=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for SQL Server databases.

        Returns a list of summary information for Microsoft SQL databases.

        :param instance_id: Filter by Microsoft SQL instance.
        :type instance_id: str
        :param effective_sla_domain_id: Filter by effective SLA domain.
        :type effective_sla_domain_id: str
        :param primary_cluster_id: Filter by primary cluster.
        :type primary_cluster_id: str
        :param is_relic: Filter by the isRelic field of the database summary
         information.
        :type is_relic: bool
        :param is_live_mount: Filter by the isLiveMount field of the database
         summary information.
        :type is_live_mount: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlDbSummaryListResponse
         <rubriklib.models.MssqlDbSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlDbSummaryListResponse
         <rubriklib.models.MssqlDbSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db'

        # Construct parameters
        query_parameters = {}
        if instance_id is not None:
            query_parameters['instance_id'] = self._serialize.query("instance_id", instance_id, 'str')
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if is_relic is not None:
            query_parameters['is_relic'] = self._serialize.query("is_relic", is_relic, 'bool')
        if is_live_mount is not None:
            query_parameters['is_live_mount'] = self._serialize.query("is_live_mount", is_live_mount, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlDbSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_mssql_db(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get detailed information for a Microsoft SQL database.

        Returns a detailed view of a Microsoft SQL database.

        :param id: ID of the Microsoft SQL database to fetch.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlDbDetail <rubriklib.models.MssqlDbDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlDbDetail <rubriklib.models.MssqlDbDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlDbDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_mssql_db(
            self, id, db_update_properties, custom_headers=None, raw=False, **operation_config):
        """Update a Microsoft SQL database.

        Update a Microsoft SQL database with the specified properties.

        :param id: ID of the Microsoft SQL database to update.
        :type id: str
        :param db_update_properties: Properties to update.
        :type db_update_properties: :class:`MssqlDbUpdate
         <rubriklib.models.MssqlDbUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlDbDetail <rubriklib.models.MssqlDbDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlDbDetail <rubriklib.models.MssqlDbDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(db_update_properties, 'MssqlDbUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlDbDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_export_mssql_db(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Export a Microsoft SQL database to a new location.

        Create a request to export a Microsoft SQL database. To check the
        result of the request, poll /mssql/request/{id}.

        :param id: ID of the Microsoft SQL database.
        :type id: str
        :param config: Configuration for the export.
        :type config: :class:`ExportMssqlDbJobConfig
         <rubriklib.models.ExportMssqlDbJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/{id}/export'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'ExportMssqlDbJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_mssql_db_missed_recoverable_ranges(
            self, id, after_time=None, before_time=None, custom_headers=None, raw=False, **operation_config):
        """Get missed recoverable ranges of a Microsoft SQL database.

        Retrieve a list of missed recoverable ranges for a Microsoft SQL
        database. For each run of one type of error, the first and last
        occurrence of the error are given.

        :param id: ID of the Microsoft SQL database.
        :type id: str
        :param after_time: Filter the missed ranges to end after this time.
         The date-time string should be in ISO8601 format, such as
         "2016-01-01T01:23:45.678".
        :type after_time: datetime
        :param before_time: Filter the missed ranges to start before this
         time. The date-time string should be in ISO8601 format, such as
         "2016-01-01T01:23:45.678".
        :type before_time: datetime
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlMissedRecoverableRangeListResponse
         <rubriklib.models.MssqlMissedRecoverableRangeListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlMissedRecoverableRangeListResponse
         <rubriklib.models.MssqlMissedRecoverableRangeListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/{id}/missed_recoverable_range'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if after_time is not None:
            query_parameters['after_time'] = self._serialize.query("after_time", after_time, 'iso-8601')
        if before_time is not None:
            query_parameters['before_time'] = self._serialize.query("before_time", before_time, 'iso-8601')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlMissedRecoverableRangeListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_missed_mssql_db_snapshots(
            self, id, after_time=None, before_time=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for missed snapshots of a SQL database.

        Returns a list of summary information for the missed snapshots of a
        Microsoft SQL database, including the time of day and the locations
        where the snapshot was missed.

        :param id: ID of the Microsoft SQL database.
        :type id: str
        :param after_time: Filter snapshots to those missed on or after this
         time. The date-time string should be in ISO8601 format, such as
         "2016-01-01T01:23:45.678".
        :type after_time: datetime
        :param before_time: Filter snapshots to those missed on or before this
         time. The date-time string should be in ISO8601 format, such as
         "2016-01-01T01:23:45.678".
        :type before_time: datetime
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MissedSnapshotListResponse
         <rubriklib.models.MissedSnapshotListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MissedSnapshotListResponse
         <rubriklib.models.MissedSnapshotListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/{id}/missed_snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if after_time is not None:
            query_parameters['after_time'] = self._serialize.query("after_time", after_time, 'iso-8601')
        if before_time is not None:
            query_parameters['before_time'] = self._serialize.query("before_time", before_time, 'iso-8601')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MissedSnapshotListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_mssql_mount(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Live Mount SQL Server database from a point in time copy.

        Create an async request to Live Mount a SQL Server database. Poll the
        task status by using /mssql/request/{id}.

        :param id: ID of the SQL Server database.
        :type id: str
        :param config: Configuration for the Live Mount.
        :type config: :class:`MountMssqlDbConfig
         <rubriklib.models.MountMssqlDbConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/{id}/mount'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'MountMssqlDbConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_mssql_db_recoverable_ranges(
            self, id, after_time=None, before_time=None, custom_headers=None, raw=False, **operation_config):
        """Get recoverable ranges of a Microsoft SQL database.

        Retrieve the recoverable ranges for a specified Microsoft SQL database.
        A begin and/or end timestamp can be provided to retrieve only the
        ranges that fall within the window.

        :param id: ID of the Microsoft SQL database.
        :type id: str
        :param after_time: Filter ranges to end after this time. The date-time
         string should be in ISO8601 format, such as
         "2016-01-01T01:23:45.678Z".
        :type after_time: datetime
        :param before_time: Filter ranges to start before this time. The
         date-time string should be in ISO8601 format, such as
         "2016-01-01T01:23:45.678".
        :type before_time: datetime
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlRecoverableRangeListResponse
         <rubriklib.models.MssqlRecoverableRangeListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlRecoverableRangeListResponse
         <rubriklib.models.MssqlRecoverableRangeListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/{id}/recoverable_range'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if after_time is not None:
            query_parameters['after_time'] = self._serialize.query("after_time", after_time, 'iso-8601')
        if before_time is not None:
            query_parameters['before_time'] = self._serialize.query("before_time", before_time, 'iso-8601')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlRecoverableRangeListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_restore_mssql_db(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Restore a Microsoft SQL database.

        Create a request to restore a SQL Server database. To check the result
        of the request, poll /mssql/request/{id}.

        :param id: ID of the Microsoft SQL database.
        :type id: str
        :param config: Configuration for the restore.
        :type config: :class:`RestoreMssqlDbJobConfig
         <rubriklib.models.RestoreMssqlDbJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/{id}/restore'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'RestoreMssqlDbJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_mssql_db_snapshot(
            self, id, after_time=None, before_time=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for snapshots of a Microsoft SQL database.

        Returns a list of summary information for snapshots of a Microsoft SQL
        database.

        :param id: ID of the Microsoft SQL database.
        :type id: str
        :param after_time: Filter snapshots to those taken on or after this
         time. The date-time string should be in ISO8601 format, such as
         "2016-01-01T01:23:45.678".
        :type after_time: datetime
        :param before_time: Filter snapshots to those taken before or on this
         time. The date-time string should be in ISO8601 format, such as
         "2016-01-01T01:23:45.678".
        :type before_time: datetime
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlDbSnapshotSummaryListResponse
         <rubriklib.models.MssqlDbSnapshotSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlDbSnapshotSummaryListResponse
         <rubriklib.models.MssqlDbSnapshotSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if after_time is not None:
            query_parameters['after_time'] = self._serialize.query("after_time", after_time, 'iso-8601')
        if before_time is not None:
            query_parameters['before_time'] = self._serialize.query("before_time", before_time, 'iso-8601')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlDbSnapshotSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_on_demand_mssql_backup(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Take an on-demand backup of a Microsoft SQL database.

        Take an on-demand backup of a Microsoft SQL database. The
        forceFullSnapshot property can be set to true to force a full snapshot.
        To check the result of the request, poll /mssql/request/{id}.

        :param id: ID of the Microsoft SQL database.
        :type id: str
        :param config: Configuration for the on-demand backup.
        :type config: :class:`MssqlBackupJobConfig
         <rubriklib.models.MssqlBackupJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'MssqlBackupJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_mssql_db_snapshots(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete all snapshots of a Microsoft SQL database.

        Deletes all snapshots of a Microsoft SQL database. The database must be
        unprotected for the operation to succeed.

        :param id: ID of the Microsoft SQL database.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def query_mssql_mount(
            self, source_database_id=None, source_database_name=None, target_instance_id=None, mounted_database_name=None, sort_by=None, sort_order=None, offset=None, limit=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for all Live Mounts of SQL Server databases.

        Returns a list with summary information for all Live Mounted SQL Server
        databases.

        :param source_database_id: Filters by the ID of the source SQL Server
         database.
        :type source_database_id: str
        :param source_database_name: Filters by the name of the source SQL
         Server database using infix search.
        :type source_database_name: str
        :param target_instance_id: Filters by the ID of the target SQL Server
         instance.
        :type target_instance_id: str
        :param mounted_database_name: Filters by the name of the mounted SQL
         Server database using infix search.
        :type mounted_database_name: str
        :param sort_by: Specifies the SQL Server Live Mount attribute to use
         in sorting the summary information. Performs an ASCII sort using the
         specified attribute, in the order specified by sort_order. Possible
         values include: 'sourceDatabaseName', 'sourceRecoveryPoint',
         'mountedDatabaseName', 'creationDate'
        :type sort_by: str
        :param sort_order: Specifies the sort order, either ascending or
         descending. Default order is ascending. Possible values include:
         'asc', 'desc'
        :type sort_order: str
        :param offset: Returns the portion of the ordered list that starts
         after the element specified by the offset number.
        :type offset: int
        :param limit: Sets the maximum number of a elements to include in the
         data array of the response.
        :type limit: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlMountSummaryListResponse
         <rubriklib.models.MssqlMountSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlMountSummaryListResponse
         <rubriklib.models.MssqlMountSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/mount'

        # Construct parameters
        query_parameters = {}
        if source_database_id is not None:
            query_parameters['source_database_id'] = self._serialize.query("source_database_id", source_database_id, 'str')
        if source_database_name is not None:
            query_parameters['source_database_name'] = self._serialize.query("source_database_name", source_database_name, 'str')
        if target_instance_id is not None:
            query_parameters['target_instance_id'] = self._serialize.query("target_instance_id", target_instance_id, 'str')
        if mounted_database_name is not None:
            query_parameters['mounted_database_name'] = self._serialize.query("mounted_database_name", mounted_database_name, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlMountSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_mssql_mount(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get detailed information for a Live Mount of a SQL Server database.

        Returns detailed information for the specified Live Mount of a SQL
        Server database.

        :param id: ID of the Live Mount to fetch.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlMountDetail <rubriklib.models.MssqlMountDetail>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlMountDetail <rubriklib.models.MssqlMountDetail>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/mount/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlMountDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_mssql_unmount(
            self, id, force=None, custom_headers=None, raw=False, **operation_config):
        """Delete a Live Mount of a SQL Server database.

        Create an async request to delete a Live Mount of a SQL Server
        database. Poll the task status by using /mssql/request/{id}.

        :param id: ID of the Live Mount to delete.
        :type id: str
        :param force: Remove all data within the Rubrik cluster related to the
         Live Mount, even if the SQL Server database cannot be contacted.
         Default value is false.
        :type force: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/mount/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if force is not None:
            query_parameters['force'] = self._serialize.query("force", force, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_mssql_db_snapshot(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details information about a Microsoft SQL database snapshot.

        Returns detailed information about a Microsoft SQL database snapshot.

        :param id: ID of the snapshot.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlDbSnapshotDetail
         <rubriklib.models.MssqlDbSnapshotDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlDbSnapshotDetail
         <rubriklib.models.MssqlDbSnapshotDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/db/snapshot/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlDbSnapshotDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_mssql_instance(
            self, root_id=None, primary_cluster_id=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for Microsoft SQL instances.

        Returns a list of summary information for Microsoft SQL instances.

        :param root_id: Include only instances that belong to this root.
        :type root_id: str
        :param primary_cluster_id: Limits the instances returned within one
         cluster specified by primary_cluster_id.
        :type primary_cluster_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlInstanceSummaryListResponse
         <rubriklib.models.MssqlInstanceSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlInstanceSummaryListResponse
         <rubriklib.models.MssqlInstanceSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/instance'

        # Construct parameters
        query_parameters = {}
        if root_id is not None:
            query_parameters['root_id'] = self._serialize.query("root_id", root_id, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlInstanceSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_mssql_instance(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get detailed information for a Microsoft SQL instance.

        Returns a detailed view of a Microsoft SQL instance.

        :param id: ID of the Microsoft SQL instance.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlInstanceDetail
         <rubriklib.models.MssqlInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlInstanceDetail
         <rubriklib.models.MssqlInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/instance/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlInstanceDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_mssql_instance(
            self, id, instance_update_properties, custom_headers=None, raw=False, **operation_config):
        """Update a Microsoft SQL instance.

        Update a Microsoft SQL instance with specified properties.

        :param id: ID of the Microsoft SQL instance.
        :type id: str
        :param instance_update_properties: Properties to update.
        :type instance_update_properties: :class:`MssqlInstanceUpdate
         <rubriklib.models.MssqlInstanceUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MssqlInstanceDetail
         <rubriklib.models.MssqlInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MssqlInstanceDetail
         <rubriklib.models.MssqlInstanceDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/instance/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(instance_update_properties, 'MssqlInstanceUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MssqlInstanceDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_mssql_async_request_status(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details for an async request.

        Returns the task object for an async request related to SQL Server
        databases.

        :param id: ID of the async request.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/mssql/request/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_session(
            self, custom_headers=None, raw=False, **operation_config):
        """Create user session.

        Create a new login session.

        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SessionSummary <rubriklib.models.SessionSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SessionSummary <rubriklib.models.SessionSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/session'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SessionSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_session(
            self, id="me", custom_headers=None, raw=False, **operation_config):
        """Delete user session.

        Closes a user session and invalidates the session token.

        :param id: Session ID or  *me* for session of bearer token.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/session/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def query_sla_domain(
            self, primary_cluster_id=None, name=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get list of SLA Domains.

        Retrieve summary information for all SLA Domains.

        :param primary_cluster_id: Limits the information retrieved to those
         SLA Domains that are associated with the Rubrik cluster ID that is
         specified by primary_cluster_id. Use **local** for the Rubrik cluster
         that is hosting the current REST API session.
        :type primary_cluster_id: str
        :param name: Limit the list information to those SLA Domains which
         match the specified SLA Domain 'name' value.
        :type name: str
        :param sort_by: Attribute to use to sort the SLA Domains summary
         information. Optionally use **_sort_order_** to specify whether to
         sort in ascending or descending order. Possible values include: 'name'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending. If not
         specified, SLA Domain summary results will be sorted in ascending
         order. Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SlaDomainSummaryListResponse
         <rubriklib.models.SlaDomainSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SlaDomainSummaryListResponse
         <rubriklib.models.SlaDomainSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/sla_domain'

        # Construct parameters
        query_parameters = {}
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SlaDomainSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_sla_domain(
            self, definition, custom_headers=None, raw=False, **operation_config):
        """Create SLA Domain.

        Create a new SLA Domain on a Rubrik cluster by specifying Domain Rules
        and policies.

        :param definition: SLA Domain definition. Two backup windows are
         allowed: one regular and one first full snapshot
        :type definition: :class:`SlaDomainDefinition
         <rubriklib.models.SlaDomainDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SlaDomainSummary <rubriklib.models.SlaDomainSummary>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SlaDomainSummary <rubriklib.models.SlaDomainSummary>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/sla_domain'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(definition, 'SlaDomainDefinition')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [201]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 201:
            deserialized = self._deserialize('SlaDomainSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_sla_domain(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get SLA Domain details.

        Retrieve summary information for a specified SLA Domain.

        :param id: ID of the SLA Domain.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SlaDomainSummary <rubriklib.models.SlaDomainSummary>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SlaDomainSummary <rubriklib.models.SlaDomainSummary>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/sla_domain/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SlaDomainSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_sla_domain(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Remove SLA Domain.

        Delete an SLA Domain from a Rubrik cluster. The SLA Domain must not be
        assigned to any VMs, filesets or databases.

        :param id: ID of the SLA Domain.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/sla_domain/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def update_sla_domain(
            self, id, update_info, custom_headers=None, raw=False, **operation_config):
        """Update SLA Domain.

        Update the properties of an SLA Domain.

        :param id: ID of the SLA Domain.
        :type id: str
        :param update_info: Object containing updated SLA Domain. Two backup
         windows are allowed: one regular and one first full snapshot
        :type update_info: :class:`SlaDomainDefinition
         <rubriklib.models.SlaDomainDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SlaDomainSummary <rubriklib.models.SlaDomainSummary>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SlaDomainSummary <rubriklib.models.SlaDomainSummary>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/sla_domain/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update_info, 'SlaDomainDefinition')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SlaDomainSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def patch_sla_domain(
            self, id, patch_info, custom_headers=None, raw=False, **operation_config):
        """Patch SLA Domain.

        Patch the properties of an SLA Domain.

        :param id: ID of the SLA Domain.
        :type id: str
        :param patch_info: Object containing the fields to be edited for SLA
         Domain. Two backup windows are allowed: one regular and one first full
         snapshot. For remote SLA domain, only archival spec edit is allowed.
        :type patch_info: :class:`SlaDomainPatchDefinition
         <rubriklib.models.SlaDomainPatchDefinition>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SlaDomainSummary <rubriklib.models.SlaDomainSummary>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SlaDomainSummary <rubriklib.models.SlaDomainSummary>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/sla_domain/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(patch_info, 'SlaDomainPatchDefinition')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SlaDomainSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_vcenter(
            self, primary_cluster_id=None, custom_headers=None, raw=False, **operation_config):
        """Get list of vCenters.

        Retrieve information for each managed vCenter, including: ID, managed
        ID, address, username, SLA ID, and primary cluster ID.

        :param primary_cluster_id: Limits the information to the Rubrik
         cluster specified by the value of primary_cluster_id. Use 'local' for
         the Rubrik cluster that is hosting the current REST API session.
        :type primary_cluster_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VcenterSummaryListResponse
         <rubriklib.models.VcenterSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VcenterSummaryListResponse
         <rubriklib.models.VcenterSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vcenter'

        # Construct parameters
        query_parameters = {}
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VcenterSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_vcenter(
            self, vcenter_detail, custom_headers=None, raw=False, **operation_config):
        """Add vCenter Server.

        Create a vCenter Server object by providing the address and account
        credentials of the vCenter Server. Initiates an asynchronous job to
        establish a connection with the vCenter Server and retrieve all
        metadata. Use GET /vcenter/{id}/status to check status.

        :param vcenter_detail: IP address and account credentials of the
         vCenter Server server, and ID of the managing Rubrik cluster.
        :type vcenter_detail: :class:`VcenterConfig
         <rubriklib.models.VcenterConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vcenter'

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(vcenter_detail, 'VcenterConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_vcenter(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get the details of a vCenter Server.

        Retrieve detailed information for a vCenter Server object.

        :param id: ID of the vCenter Server.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VcenterDetail <rubriklib.models.VcenterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VcenterDetail <rubriklib.models.VcenterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vcenter/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VcenterDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def patch_vcenter(
            self, id, update_properties, custom_headers=None, raw=False, **operation_config):
        """Update the SLA Domain for a vCenter Server.

        Update the SLA Domain that is configured for a vCenter Server.

        :param id: ID of the vCenter Server.
        :type id: str
        :param update_properties: Object containing updated vCenter Server
         information.
        :type update_properties: :class:`VcenterPatch
         <rubriklib.models.VcenterPatch>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VcenterSummary <rubriklib.models.VcenterSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VcenterSummary <rubriklib.models.VcenterSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vcenter/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update_properties, 'VcenterPatch')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VcenterSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_vcenter(
            self, id, update_properties, custom_headers=None, raw=False, **operation_config):
        """Update vCenter Server.

        Update the address, username and password of the specified vCenter
        Server object.

        :param id: ID of the vCenter Server.
        :type id: str
        :param update_properties: Object containing updated vCenter Server
         information.
        :type update_properties: :class:`VcenterConfig
         <rubriklib.models.VcenterConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VcenterSummary <rubriklib.models.VcenterSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VcenterSummary <rubriklib.models.VcenterSummary>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vcenter/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update_properties, 'VcenterConfig')

        # Construct and send request
        request = self._client.put(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VcenterSummary', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_vcenter(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Remove vCenter Server.

        Initiates an asynchronous job to remove a vCenter Server object. The
        vCenter Server cannot have VMs mounted through the Rubrik cluster.

        :param id: ID of the vCenter Server to remove.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vcenter/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_refresh(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Refresh vCenter Server metadata.

        Create a job to refresh the metadata for the specified vCenter Server.

        :param id: ID of the vCenter Server
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vcenter/{id}/refresh'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_vcenter_async_request_status(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get vCenter Server async request.

        Get details about a vcenter related async request.

        :param id: ID of the request
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vcenter/request/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_vm(
            self, effective_sla_domain_id=None, primary_cluster_id=None, limit=None, offset=None, is_relic=None, name=None, sla_assignment=None, sort_by=None, sort_order=None, custom_headers=None, raw=False, **operation_config):
        """Get list of VMs.

        Get summary of all the VMs.

        :param effective_sla_domain_id: Filter by ID of effective SLA Domain.
        :type effective_sla_domain_id: str
        :param primary_cluster_id: Filter by primary cluster ID, or **local**.
        :type primary_cluster_id: str
        :param limit: Limit the number of matches returned.
        :type limit: int
        :param offset: Ignore these many matches in the beginning.
        :type offset: int
        :param is_relic: Filter by the isRelic field of the virtual machine.
         When this parameter is not set, return both relic and non-relic
         virtual machines.
        :type is_relic: bool
        :param name: Search by using a virtual machine name.
        :type name: str
        :param sla_assignment: Filter by SLA Domain assignment type. Possible
         values include: 'Derived', 'Direct', 'Unassigned'
        :type sla_assignment: str
        :param sort_by: Sort results based on the specified attribute.
         Possible values include: 'effectiveSlaDomainName', 'name',
         'folderPath', 'infraPath'
        :type sort_by: str
        :param sort_order: Sort order, either ascending or descending.
         Possible values include: 'asc', 'desc'
        :type sort_order: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VirtualMachineSummaryListResponse
         <rubriklib.models.VirtualMachineSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VirtualMachineSummaryListResponse
         <rubriklib.models.VirtualMachineSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm'

        # Construct parameters
        query_parameters = {}
        if effective_sla_domain_id is not None:
            query_parameters['effective_sla_domain_id'] = self._serialize.query("effective_sla_domain_id", effective_sla_domain_id, 'str')
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if is_relic is not None:
            query_parameters['is_relic'] = self._serialize.query("is_relic", is_relic, 'bool')
        if name is not None:
            query_parameters['name'] = self._serialize.query("name", name, 'str')
        if sla_assignment is not None:
            query_parameters['sla_assignment'] = self._serialize.query("sla_assignment", sla_assignment, 'str')
        if sort_by is not None:
            query_parameters['sort_by'] = self._serialize.query("sort_by", sort_by, 'str')
        if sort_order is not None:
            query_parameters['sort_order'] = self._serialize.query("sort_order", sort_order, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VirtualMachineSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_vm(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get VM details.

        Retrieve details for a virtual machine.

        :param id: ID of the virtual machine.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VirtualMachineDetail
         <rubriklib.models.VirtualMachineDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VirtualMachineDetail
         <rubriklib.models.VirtualMachineDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VirtualMachineDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_vm(
            self, id, vm_update_properties, custom_headers=None, raw=False, **operation_config):
        """Update VM.

        Update a virtual machine with specified properties. Use the
        guestCredential field to update the guest credential for a specified
        virtual machine.

        :param id: ID of virtual machine.
        :type id: str
        :param vm_update_properties: Properties to update.
        :type vm_update_properties: :class:`VirtualMachineUpdateWithSecret
         <rubriklib.models.VirtualMachineUpdateWithSecret>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VirtualMachineDetail
         <rubriklib.models.VirtualMachineDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VirtualMachineDetail
         <rubriklib.models.VirtualMachineDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(vm_update_properties, 'VirtualMachineUpdateWithSecret')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VirtualMachineDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def search_vm(
            self, id, path, custom_headers=None, raw=False, **operation_config):
        """Search for a file from a VM.

        Search for a file in the snapshots of a a virtual machine. Specify the
        file by full path prefix or filename prefix.

        :param id: ID of the virtual machine.
        :type id: str
        :param path: The path query. Use either a path prefix or a filename
         prefix.
        :type path: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`SearchResponseListResponse
         <rubriklib.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`SearchResponseListResponse
         <rubriklib.models.SearchResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/{id}/search'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['path'] = self._serialize.query("path", path, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('SearchResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_snapshot(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get list of snapshots of VM.

        Retrieve summary information for the snapshots of a virtual machine.

        :param id: ID of the virtual machine.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VmSnapshotSummaryListResponse
         <rubriklib.models.VmSnapshotSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VmSnapshotSummaryListResponse
         <rubriklib.models.VmSnapshotSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VmSnapshotSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_on_demand_backup(
            self, id, config=None, custom_headers=None, raw=False, **operation_config):
        """Create an on-demand snapshot for a VM.

        Use the ID of a virtual machine to create an on-demand snapshot.

        :param id: ID of the virtual machine.
        :type id: str
        :param config: Configuration for the on-demand snapshot.
        :type config: :class:`BaseOnDemandSnapshotConfig
         <rubriklib.models.BaseOnDemandSnapshotConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if config is not None:
            body_content = self._serialize.body(config, 'BaseOnDemandSnapshotConfig')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_vmware_snapshots(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Delete all snapshots of VM.

        Delete all of the snapshots from a virtual machine.

        :param id: Virtual machine ID.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/{id}/snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def run_guest_os_script(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Run guest OS script.

        Run the specified preBackup, postSnap, or postBackup script in the
        guest OS of a virtual machine. The script must exist and meet
        requirements.

        :param id: ID of the virtual machine.
        :type id: str
        :param config: Configuration used to run the specified preBackup,
         postSnap, or postBackup guest OS script.
        :type config: :class:`VmGuestScriptRunConfig
         <rubriklib.models.VmGuestScriptRunConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/{id}/guest_script/run'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'VmGuestScriptRunConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def missed_snapshots(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details about missed snapshots for a VM.

        Retrieve details about the missed snapshots for a virtual machine.

        :param id: ID of a virtual machine.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`MissedSnapshotListResponse
         <rubriklib.models.MissedSnapshotListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`MissedSnapshotListResponse
         <rubriklib.models.MissedSnapshotListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/{id}/missed_snapshot'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('MissedSnapshotListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_async_request_status(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get asynchronous request details for VM.

        Get the details of an asynchronous request that involves a VMware
        virtual machine.

        :param id: ID of an asynchronous request.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/request/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_snapshot(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get VM snapshot details.

        Retrieve detailed information about a virtual machine snapshot.

        :param id: ID of a snapshot.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VmSnapshotDetail <rubriklib.models.VmSnapshotDetail>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VmSnapshotDetail <rubriklib.models.VmSnapshotDetail>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/snapshot/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VmSnapshotDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def delete_vmware_snapshot(
            self, id, location, custom_headers=None, raw=False, **operation_config):
        """Delete VM snapshot.

        Designate a snapshot as expired and available for garbage collection.
        The snapshot must be an on-demand snapshot or a snapshot from a virtual
        machine that is not assigned to an SLA Domain.

        :param id: ID of snapshot.
        :type id: str
        :param location: Location of the snapshot. Use **_local_** to delete
         only the local copy of the snapshot. Or use **_all_** to delete the
         snapshot locally, on a replication target, and at an archival
         location. Possible values include: 'all', 'local'
        :type location: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: None or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/snapshot/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['location'] = self._serialize.query("location", location, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [204]:
            raise HttpOperationError(self._deserialize, response)

        if raw:
            client_raw_response = ClientRawResponse(None, response)
            return client_raw_response

    def browse_vmware_snapshot(
            self, id, path, offset=None, limit=None, custom_headers=None, raw=False, **operation_config):
        """List files in VM snapshot.

        For a virtual machine snapshot, list the directories and files that are
        beneath a specified file system path.

        :param id: ID of snapshot
        :type id: str
        :param path: The absolute path of the starting point for the directory
         listing.
        :type path: str
        :param offset: Starting position in the list of path entries contained
         in the query results, sorted by lexicographical order. The response
         includes the specified numbered entry and all higher numbered entries.
        :type offset: int
        :param limit: Maximum number of entries in the response.
        :type limit: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`BrowseResponseListResponse
         <rubriklib.models.BrowseResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`BrowseResponseListResponse
         <rubriklib.models.BrowseResponseListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/snapshot/{id}/browse'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        query_parameters['path'] = self._serialize.query("path", path, 'str')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int')
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('BrowseResponseListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_download_snapshot_from_cloud(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Download snapshot from archive.

        Provides a method for retrieving a snapshot, that is not available
        locally, from an archival location.

        :param id: ID of snapshot
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/snapshot/{id}/download'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_download_file_job(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Download file from VM snapshot.

        Create a request to download a file from a virtual machine snapshot.

        :param id: ID of a snapshot.
        :type id: str
        :param config: Configuration for the file download request.
        :type config: :class:`DownloadFileJobConfig
         <rubriklib.models.DownloadFileJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/snapshot/{id}/download_file'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'DownloadFileJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_export(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Export VM snapshot.

        Export a virtual machine from a snapshot, using a specified hypervisor
        host as the datastore.

        :param id: ID of a snapshot.
        :type id: str
        :param config: Configuration for the export request.
        :type config: :class:`ExportSnapshotJobConfig
         <rubriklib.models.ExportSnapshotJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/snapshot/{id}/export'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'ExportSnapshotJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_instant_recovery(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Instantly recover a VM.

        Instantly recovery a virtual machine from a snapshot. The Instant
        Recovery request starts the virtual machine with networking enabled and
        renames and powers off the source virtual machine, if it still exists.

        :param id: ID of Snapshot
        :type id: str
        :param config: Configuration for the Instant Recovery request.
        :type config: :class:`InstantRecoveryJobConfig
         <rubriklib.models.InstantRecoveryJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/snapshot/{id}/instant_recover'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'InstantRecoveryJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_restore_file_job(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Restore file from VM snapshot.

        Create a request to restore a file or folder to the source virtual
        machine.

        :param id: ID of a snapshot.
        :type id: str
        :param config: Configuration for the restore request.
        :type config: :class:`RestoreFileJobConfig
         <rubriklib.models.RestoreFileJobConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/snapshot/{id}/restore_file'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'RestoreFileJobConfig')

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_mount_v1(
            self, id, config=None, custom_headers=None, raw=False, **operation_config):
        """Live mount a VM from a snapshot.

        Create a request to Live Mount a virtual machine from a snapshot using
        a specified configuration.

        :param id: ID of a snapshot.
        :type id: str
        :param config: Configuration for the Live Mount request.
        :type config: :class:`MountSnapshotJobConfigV1
         <rubriklib.models.MountSnapshotJobConfigV1>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/snapshot/{id}/mount'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        if config is not None:
            body_content = self._serialize.body(config, 'MountSnapshotJobConfigV1')
        else:
            body_content = None

        # Construct and send request
        request = self._client.post(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_mount_v1(
            self, vm_id=None, offset=None, limit=None, custom_headers=None, raw=False, **operation_config):
        """Get Live Mount information.

        Retrieve summary information about Live Mount activity.

        :param vm_id: Filters information by virtual machine ID.
        :type vm_id: str
        :param offset: Starting position in the list of Live Mount entries
         contained in the response. The summary information includes the
         specified numbered entry and all higher numbered entries. Use with
         **_limit_** to retrieve the summary information as smaller groups of
         entries, e.g. for paging of the results.
        :type offset: int
        :param limit: Limit the summary information to a specified maximum
         number of entries. Optionally, use with **_offset_** to start the
         count at a specified point. Default is 25.
        :type limit: int
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VmwareVmMountSummaryV1ListResponse
         <rubriklib.models.VmwareVmMountSummaryV1ListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VmwareVmMountSummaryV1ListResponse
         <rubriklib.models.VmwareVmMountSummaryV1ListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/snapshot/mount'

        # Construct parameters
        query_parameters = {}
        if vm_id is not None:
            query_parameters['vm_id'] = self._serialize.query("vm_id", vm_id, 'str')
        if offset is not None:
            query_parameters['offset'] = self._serialize.query("offset", offset, 'int', minimum=0)
        if limit is not None:
            query_parameters['limit'] = self._serialize.query("limit", limit, 'int', minimum=0)

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VmwareVmMountSummaryV1ListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_mount_v1(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get information for a Live Mount.

        Retrieve detailed information for a specified Live Mount.

        :param id: ID of a Live Mount.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VmwareVmMountDetailV1
         <rubriklib.models.VmwareVmMountDetailV1>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VmwareVmMountDetailV1
         <rubriklib.models.VmwareVmMountDetailV1>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/snapshot/mount/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VmwareVmMountDetailV1', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_mount(
            self, id, config, custom_headers=None, raw=False, **operation_config):
        """Power a Live Mount on and off.

        Power a specified Live Mount virtual machine on or off. Pass **_true_**
        to power the virtual machine on and pass **_false_** to power the
        virtual machine off.

        :param id: ID of a Live Mount.
        :type id: str
        :param config: Power state configuration.
        :type config: :class:`UpdateMountConfig
         <rubriklib.models.UpdateMountConfig>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VmwareVmMountDetailV1
         <rubriklib.models.VmwareVmMountDetailV1>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VmwareVmMountDetailV1
         <rubriklib.models.VmwareVmMountDetailV1>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/snapshot/mount/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(config, 'UpdateMountConfig')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VmwareVmMountDetailV1', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def create_unmount(
            self, id, force=None, custom_headers=None, raw=False, **operation_config):
        """Delete a Live Mount VM.

        Create a request to delete a Live Mount virtual machine.

        :param id: ID of a Live Mount
        :type id: str
        :param force: Force unmount to remove metadata when the datastore of
         the Live Mount virtual machine was moved off of the Rubrik cluster.
        :type force: bool
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`AsyncRequestStatus
         <rubriklib.models.AsyncRequestStatus>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/snapshot/mount/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}
        if force is not None:
            query_parameters['force'] = self._serialize.query("force", force, 'bool')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.delete(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [202]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 202:
            deserialized = self._deserialize('AsyncRequestStatus', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_virtual_disk(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Details about the specific Virtual Disk.

        Detailed about the specific Virtual Disk.

        :param id: ID of the Virtual Disk
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VirtualDiskDetail
         <rubriklib.models.VirtualDiskDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VirtualDiskDetail
         <rubriklib.models.VirtualDiskDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/virtual_disk/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VirtualDiskDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_virtual_disk(
            self, id, update_info, custom_headers=None, raw=False, **operation_config):
        """Update a specific Virtual Disk.

        Update a specific Virtual Disk.

        :param id: ID of the Virtual Disk
        :type id: str
        :param update_info: Virtual Disk update information
        :type update_info: :class:`VirtualDiskUpdate
         <rubriklib.models.VirtualDiskUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VirtualDiskDetail
         <rubriklib.models.VirtualDiskDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VirtualDiskDetail
         <rubriklib.models.VirtualDiskDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/vm/virtual_disk/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update_info, 'VirtualDiskUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VirtualDiskDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_vmware_host(
            self, primary_cluster_id=None, custom_headers=None, raw=False, **operation_config):
        """Get summary of all the ESXi hypervisor.

        Get summary of all the ESXi hypervisor.

        :param primary_cluster_id: ID of the Primary cluster
        :type primary_cluster_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VmwareHostSummaryListResponse
         <rubriklib.models.VmwareHostSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VmwareHostSummaryListResponse
         <rubriklib.models.VmwareHostSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/host'

        # Construct parameters
        query_parameters = {}
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VmwareHostSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_vmware_host(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get details of a ESXi hypervisor.

        Get details of a ESXi hypervisor.

        :param id: ID of the VMWare host
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VmwareHostDetail <rubriklib.models.VmwareHostDetail>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VmwareHostDetail <rubriklib.models.VmwareHostDetail>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/host/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VmwareHostDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def update_vmware_host(
            self, id, update_properties, custom_headers=None, raw=False, **operation_config):
        """Update the SLA Domain for an ESXi hypervisor.

        Update the SLA Domain that is configured for an ESXi hypervisor.

        :param id: ID of the ESXi hypervisor
        :type id: str
        :param update_properties: Object with changes for the ESXi hypervisor
         information.
        :type update_properties: :class:`VmwareHostUpdate
         <rubriklib.models.VmwareHostUpdate>`
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`VmwareHostDetail <rubriklib.models.VmwareHostDetail>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`VmwareHostDetail <rubriklib.models.VmwareHostDetail>`
         or :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/vmware/host/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct body
        body_content = self._serialize.body(update_properties, 'VmwareHostUpdate')

        # Construct and send request
        request = self._client.patch(url, query_parameters)
        response = self._client.send(
            request, header_parameters, body_content, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('VmwareHostDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def query_windows_cluster(
            self, primary_cluster_id=None, custom_headers=None, raw=False, **operation_config):
        """Get summary information for Windows clusters.

        Returns a list of summary information for Windows server failover
        clusters.

        :param primary_cluster_id: Filter by primary_cluster_id. Use **local**
         for the local cluster.
        :type primary_cluster_id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`WindowsClusterSummaryListResponse
         <rubriklib.models.WindowsClusterSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`WindowsClusterSummaryListResponse
         <rubriklib.models.WindowsClusterSummaryListResponse>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/windows_cluster'

        # Construct parameters
        query_parameters = {}
        if primary_cluster_id is not None:
            query_parameters['primary_cluster_id'] = self._serialize.query("primary_cluster_id", primary_cluster_id, 'str')

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WindowsClusterSummaryListResponse', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized

    def get_windows_cluster(
            self, id, custom_headers=None, raw=False, **operation_config):
        """Get detailed information for a Windows cluster.

        Returns a detailed view of a Windows server failover cluster.

        :param id: ID of the Windows cluster.
        :type id: str
        :param dict custom_headers: headers that will be added to the request
        :param bool raw: returns the direct response alongside the
         deserialized response
        :param operation_config: :ref:`Operation configuration
         overrides<msrest:optionsforoperations>`.
        :return: :class:`WindowsClusterDetail
         <rubriklib.models.WindowsClusterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>` if
         raw=true
        :rtype: :class:`WindowsClusterDetail
         <rubriklib.models.WindowsClusterDetail>` or
         :class:`ClientRawResponse<msrest.pipeline.ClientRawResponse>`
        :raises:
         :class:`HttpOperationError<msrest.exceptions.HttpOperationError>`
        """
        # Construct URL
        url = '/v1/windows_cluster/{id}'
        path_format_arguments = {
            'id': self._serialize.url("id", id, 'str')
        }
        url = self._client.format_url(url, **path_format_arguments)

        # Construct parameters
        query_parameters = {}

        # Construct headers
        header_parameters = {}
        header_parameters['Content-Type'] = 'application/json; charset=utf-8'
        if custom_headers:
            header_parameters.update(custom_headers)

        # Construct and send request
        request = self._client.get(url, query_parameters)
        response = self._client.send(request, header_parameters, **operation_config)

        if response.status_code not in [200]:
            raise HttpOperationError(self._deserialize, response)

        deserialized = None

        if response.status_code == 200:
            deserialized = self._deserialize('WindowsClusterDetail', response)

        if raw:
            client_raw_response = ClientRawResponse(deserialized, response)
            return client_raw_response

        return deserialized
